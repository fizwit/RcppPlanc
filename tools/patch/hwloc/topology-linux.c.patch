Subject: [PATCH] topology-linux.c.patch
---
Index: hwloc/topology-linux.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hwloc/topology-linux.c b/hwloc/topology-linux.c
--- a/hwloc/topology-linux.c	(revision f262ce42ff5a007a8f247b546a6fc322b2922d1e)
+++ b/hwloc/topology-linux.c	(date 1699469606073)
@@ -20,7 +20,7 @@
 #include <stdio.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <assert.h>
+//#include <assert.h>
 #ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
@@ -1431,7 +1431,7 @@
      size_t setsize;
 
      last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);
-     assert (last != -1);
+     //assert (last != -1);
 
      setsize = CPU_ALLOC_SIZE(last+1);
      plinux_set = CPU_ALLOC(last+1);
@@ -1722,7 +1722,7 @@
 
 #ifdef HWLOC_DEBUG
   /* max_os_index comes from hwloc_linux_find_kernel_max_numnodes() so it's a multiple of HWLOC_BITS_PER_LONG */
-  assert(!(max_os_index%HWLOC_BITS_PER_LONG));
+  //assert(!(max_os_index%HWLOC_BITS_PER_LONG));
 #endif
 
   hwloc_bitmap_zero(nodeset);
@@ -2588,7 +2588,7 @@
   uint64_t remaining_local_memory;
   int err;
 
-  sprintf(path, "/sys/devices/system/node/node%d/hugepages", node);
+  snprintf(path, 42, "/sys/devices/system/node/node%d/hugepages", node);
   err = hwloc_stat(path, &st, data->root_fd);
   if (!err) {
     types = 1 /* normal non-huge size */ + st.st_nlink - 2 /* ignore . and .. */;
@@ -2610,7 +2610,7 @@
   memory->page_types_len = 1; /* we'll increase it when successfully getting hugepage info */
 
   /* get the total memory */
-  sprintf(meminfopath, "/sys/devices/system/node/node%d/meminfo", node);
+  snprintf(meminfopath, 40, "/sys/devices/system/node/node%d/meminfo", node);
   hwloc_parse_meminfo_info(data, meminfopath,
 			   &memory->local_memory);
   remaining_local_memory = memory->local_memory;
@@ -2646,7 +2646,7 @@
 
     /* Linux nodeX/distance file contains distance from X to other localities (from ACPI SLIT table or so),
      * store them in slots X*N...X*N+N-1 */
-    sprintf(distancepath, "/sys/devices/system/node/node%u/distance", osnode);
+    snprintf(distancepath, 41, "/sys/devices/system/node/node%u/distance", osnode);
     if (hwloc_read_path_by_length(distancepath, string, len, fsroot_fd) <= 0)
       goto out_with_string;
 
@@ -2784,36 +2784,36 @@
     return 0;
 
   if (nbnodes != 2 && nbnodes != 4 && nbnodes != 8) {
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, nbnodes (%u) isn't 2, 4 or 8.\n", nbnodes);
+    // if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, nbnodes (%u) isn't 2, 4 or 8.\n", nbnodes);
     return -1;
   }
 
   if (!distances) {
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix missing.\n");
+    // if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix missing.\n");
     return -1;
   }
 
   for(i=0; i<nbnodes; i++) {
     /* check we have 10 on the diagonal */
     if (distances[i*nbnodes+i] != 10) {
-      if (HWLOC_SHOW_CRITICAL_ERRORS())
-        fprintf(stderr, "hwloc/linux: hwloc/linux: Ignoring KNL NUMA quirk, distance matrix does not contain 10 on the diagonal.\n");
+      // if (HWLOC_SHOW_CRITICAL_ERRORS())
+      //  fprintf(stderr, "hwloc/linux: hwloc/linux: Ignoring KNL NUMA quirk, distance matrix does not contain 10 on the diagonal.\n");
       return -1;
     }
     for(j=i+1; j<nbnodes; j++) {
       uint64_t distance = distances[i*nbnodes+j];
       /* check things are symmetric */
       if (distance != distances[i+j*nbnodes]) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix isn't symmetric.\n");
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix isn't symmetric.\n");
 	return -1;
       }
       /* check everything outside the diagonal is > 10 */
       if (distance <= 10) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix contains values <= 10.\n");
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix contains values <= 10.\n");
 	return -1;
       }
       /* did we already see this value? */
@@ -2825,8 +2825,8 @@
       if (k == summary->nb_values) {
 	/* add a new value */
 	if (k == 4) {
-          if (HWLOC_SHOW_CRITICAL_ERRORS())
-            fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix contains more than 4 different values.\n");
+          // if (HWLOC_SHOW_CRITICAL_ERRORS())
+          //  fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix contains more than 4 different values.\n");
 	  return -1;
 	}
 	summary->values[k].value = distance;
@@ -2840,25 +2840,25 @@
 
   if (nbnodes == 2) {
     if (summary->nb_values != 2) {
-      if (HWLOC_SHOW_CRITICAL_ERRORS())
-        fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix for 2 nodes cannot contain %u different values instead of 2.\n",
-                summary->nb_values);
+      // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        // fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix for 2 nodes cannot contain %u different values instead of 2.\n",
+        //        summary->nb_values);
       return -1;
     }
 
   } else if (nbnodes == 4) {
     if (summary->nb_values != 2 && summary->nb_values != 4) {
-      if (HWLOC_SHOW_CRITICAL_ERRORS())
-        fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix for 8 nodes cannot contain %u different values instead of 2 or 4.\n",
-                summary->nb_values);
+      //if (HWLOC_SHOW_CRITICAL_ERRORS())
+        // fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix for 8 nodes cannot contain %u different values instead of 2 or 4.\n",
+        //        summary->nb_values);
       return -1;
     }
 
   } else if (nbnodes == 8) {
     if (summary->nb_values != 4) {
-      if (HWLOC_SHOW_CRITICAL_ERRORS())
-        fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix for 8 nodes cannot contain %u different values instead of 4.\n",
-                summary->nb_values);
+      // if (HWLOC_SHOW_CRITICAL_ERRORS())
+      //  fprintf(stderr, "hwloc/linux: Ignoring KNL NUMA quirk, distance matrix for 8 nodes cannot contain %u different values instead of 4.\n",
+      //          summary->nb_values);
       return -1;
     }
 
@@ -3032,7 +3032,7 @@
 
   /* file must start with version information */
   if (sscanf(data_beg, "version: %d", &version) != 1) {
-    fprintf(stderr, "hwloc/linux/hwdata: Invalid knl_memoryside_cache header, expected \"version: <int>\".\n");
+  //  fprintf(stderr, "hwloc/linux/hwdata: Invalid knl_memoryside_cache header, expected \"version: <int>\".\n");
     return -1;
   }
 
@@ -3388,16 +3388,16 @@
       && strcmp(hwdata.cluster_mode, "Quadrant")
       && strcmp(hwdata.cluster_mode, "SNC2")
       && strcmp(hwdata.cluster_mode, "SNC4")) {
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: Failed to find a usable KNL cluster mode (%s)\n", hwdata.cluster_mode);
+    //if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: Failed to find a usable KNL cluster mode (%s)\n", hwdata.cluster_mode);
     goto error;
   }
   if (strcmp(hwdata.memory_mode, "Cache")
       && strcmp(hwdata.memory_mode, "Flat")
       && strcmp(hwdata.memory_mode, "Hybrid25")
       && strcmp(hwdata.memory_mode, "Hybrid50")) {
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: Failed to find a usable KNL memory mode (%s)\n", hwdata.memory_mode);
+    // if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: Failed to find a usable KNL memory mode (%s)\n", hwdata.memory_mode);
     goto error;
   }
 
@@ -3418,8 +3418,8 @@
     if (!strcmp(hwdata.memory_mode, "Cache")) {
       /* Quadrant-Cache */
       if (nbnodes != 1) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 1 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 1 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       hwloc_linux_knl_add_cluster(topology, nodes[0], NULL, &hwdata, mscache_as_l3, 1, failednodes);
@@ -3427,8 +3427,8 @@
     } else {
       /* Quadrant-Flat/Hybrid */
       if (nbnodes != 2) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       if (!strcmp(hwdata.memory_mode, "Flat"))
@@ -3440,8 +3440,8 @@
     if (!strcmp(hwdata.memory_mode, "Cache")) {
       /* SNC2-Cache */
       if (nbnodes != 2) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       hwloc_linux_knl_add_cluster(topology, nodes[0], NULL, &hwdata, mscache_as_l3, 2, failednodes);
@@ -3451,13 +3451,13 @@
       /* SNC2-Flat/Hybrid */
       unsigned ddr[2], mcdram[2];
       if (nbnodes != 4) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       if (hwloc_linux_knl_identify_4nodes(distances, &dist, ddr, mcdram) < 0) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "Uhwloc/linux: nexpected distance layout for mode %s-%s\n", hwdata.cluster_mode, hwdata.memory_mode);
+        //if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "Uhwloc/linux: nexpected distance layout for mode %s-%s\n", hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       if (!strcmp(hwdata.memory_mode, "Flat"))
@@ -3470,8 +3470,8 @@
     if (!strcmp(hwdata.memory_mode, "Cache")) {
       /* SNC4-Cache */
       if (nbnodes != 4) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 4 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
+        //if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 4 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       hwloc_linux_knl_add_cluster(topology, nodes[0], NULL, &hwdata, mscache_as_l3, 4, failednodes);
@@ -3483,13 +3483,13 @@
       /* SNC4-Flat/Hybrid */
       unsigned ddr[4], mcdram[4];
       if (nbnodes != 8) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Found %u NUMA nodes instead of 2 in mode %s-%s\n", nbnodes, hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       if (hwloc_linux_knl_identify_8nodes(distances, &dist, ddr, mcdram) < 0) {
-        if (HWLOC_SHOW_CRITICAL_ERRORS())
-          fprintf(stderr, "hwloc/linux: Unexpected distance layout for mode %s-%s\n", hwdata.cluster_mode, hwdata.memory_mode);
+        // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        //  fprintf(stderr, "hwloc/linux: Unexpected distance layout for mode %s-%s\n", hwdata.cluster_mode, hwdata.memory_mode);
 	goto error;
       }
       if (!strcmp(hwdata.memory_mode, "Flat"))
@@ -3568,10 +3568,10 @@
    * access0 contains the fastest of GI and CPU. access1 contains the fastest of CPU.
    * Try access1 to avoid GI if any, or fallback to access0 otherwise.
    */
-  sprintf(accesspath, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
+  snprintf(accesspath, 51, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
   dir = hwloc_opendir(accesspath, data->root_fd);
   if (!dir) {
-    sprintf(accesspath, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
+    snprintf(accesspath, 51, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
     dir = hwloc_opendir(accesspath, data->root_fd);
     if (!dir)
       return -1;
@@ -3610,20 +3610,20 @@
    * access0 contains the fastest of GI and CPU. access1 contains the fastest of CPU.
    * Try access1 to avoid GI if any, or fallback to access0 otherwise.
    */
-  sprintf(accessdirpath, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
+  snprintf(accessdirpath, 51, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
   if (hwloc_access(accessdirpath, X_OK, data->root_fd) < 0)
-    sprintf(accessdirpath, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
+    snprintf(accessdirpath, 51, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
 
   loc.type = HWLOC_LOCATION_TYPE_CPUSET;
   loc.location.cpuset = node->cpuset;
 
   /* bandwidth in MiB/s and latency in ns, just like in our memattrs API */
 
-  sprintf(accesspath, "%s/read_bandwidth", accessdirpath);
+  snprintf(accesspath, SYSFS_NUMA_NODE_PATH_LEN+20, "%s/read_bandwidth", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &rbw, data->root_fd) == 0 && rbw > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_READ_BANDWIDTH, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, rbw);
   }
-  sprintf(accesspath, "%s/write_bandwidth", accessdirpath);
+  snprintf(accesspath, SYSFS_NUMA_NODE_PATH_LEN+20, "%s/write_bandwidth", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &wbw, data->root_fd) == 0 && wbw > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_WRITE_BANDWIDTH, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, wbw);
   }
@@ -3631,11 +3631,11 @@
   if (rbw > 0 && wbw > 0)
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_BANDWIDTH, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, (rbw+wbw)/2);
 
-  sprintf(accesspath, "%s/read_latency", accessdirpath);
+  snprintf(accesspath, SYSFS_NUMA_NODE_PATH_LEN+20, "%s/read_latency", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &rlat, data->root_fd) == 0 && rlat > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_READ_LATENCY, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, rlat);
   }
-  sprintf(accesspath, "%s/write_latency", accessdirpath);
+  snprintf(accesspath, SYSFS_NUMA_NODE_PATH_LEN+20, "%s/write_latency", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &wlat, data->root_fd) == 0 && wlat > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_WRITE_LATENCY, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, wlat);
   }
@@ -3660,7 +3660,7 @@
   DIR *mscdir;
   struct dirent *dirent;
 
-  sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache", osnode);
+  snprintf(mscpath, 50, "/sys/devices/system/node/node%u/memory_side_cache", osnode);
   mscdir = hwloc_opendir(mscpath, data->root_fd);
   if (!mscdir)
     return -1;
@@ -3677,15 +3677,15 @@
 
     depth = atoi(dirent->d_name+5);
 
-    sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache/index%u/size", osnode, depth);
+    snprintf(mscpath, 63, "/sys/devices/system/node/node%u/memory_side_cache/index%u/size", osnode, depth);
     if (hwloc_read_path_as_uint64(mscpath, &size, data->root_fd) < 0)
       continue;
 
-    sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache/index%u/line_size", osnode, depth);
+    snprintf(mscpath, 68, "/sys/devices/system/node/node%u/memory_side_cache/index%u/line_size", osnode, depth);
     if (hwloc_read_path_as_uint(mscpath, &line_size, data->root_fd) < 0)
       continue;
 
-    sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache/index%u/indexing", osnode, depth);
+    snprintf(mscpath, 67, "/sys/devices/system/node/node%u/memory_side_cache/index%u/indexing", osnode, depth);
     if (hwloc_read_path_as_uint(mscpath, &associativity, data->root_fd) < 0)
       continue;
     /* 0 for direct-mapped, 1 for indexed (don't know how many ways), 2 for custom/other */
@@ -3835,7 +3835,7 @@
   nodeset = hwloc__alloc_read_path_as_cpulist("/sys/devices/system/node/online", data->root_fd);
   if (nodeset) {
     int _nbnodes = hwloc_bitmap_weight(nodeset);
-    assert(_nbnodes >= 1);
+    //assert(_nbnodes >= 1);
     nbnodes = (unsigned)_nbnodes;
     hwloc_debug_bitmap("possible NUMA nodes %s\n", nodeset);
     goto found;
@@ -3864,7 +3864,7 @@
   }
   closedir(dir);
 
-  assert(nbnodes >= 1); /* linux cannot have a "node/" subdirectory without at least one "node%d" */
+  //assert(nbnodes >= 1); /* linux cannot have a "node/" subdirectory without at least one "node%d" */
 
   /* we don't know if sysfs returns nodes in order, we can't merge above and below loops */
 
@@ -3875,8 +3875,8 @@
     char *sn, *tn;
     hwloc_bitmap_asprintf(&sn, nodeset);
     hwloc_bitmap_asprintf(&tn, topology->levels[0][0]->nodeset);
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: ignoring nodes because nodeset %s doesn't match existing nodeset %s.\n", tn, sn);
+    // if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: ignoring nodes because nodeset %s doesn't match existing nodeset %s.\n", tn, sn);
     free(sn);
     free(tn);
     hwloc_bitmap_free(nodeset);
@@ -3942,7 +3942,7 @@
   for(node=hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, NULL);
       node != NULL;
       node = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, node)) {
-    assert(node); /* list_sysfsnode() ensured that sysfs nodes and existing nodes match */
+    //assert(node); /* list_sysfsnode() ensured that sysfs nodes and existing nodes match */
 
     /* hwloc_parse_nodes_distances() requires nodes in physical index order,
      * and inserting distances requires nodes[] and indexes[] in same order.
@@ -4028,7 +4028,7 @@
     hwloc_bitmap_t cpuset;
 
     osnode = indexes[i];
-    sprintf(nodepath, "/sys/devices/system/node/node%u/cpumap", osnode);
+    snprintf(nodepath, 39, "/sys/devices/system/node/node%u/cpumap", osnode);
     cpuset = hwloc__alloc_read_path_as_cpumask(nodepath, data->root_fd);
     if (!cpuset) {
       /* This NUMA object won't be inserted, we'll ignore distances */
@@ -4045,8 +4045,8 @@
 	failednodes++;
 	continue;
       }
-      if (HWLOC_SHOW_CRITICAL_ERRORS())
-        fprintf(stderr, "hwloc/linux: node P#%u cpuset intersects with previous nodes, forcing its acceptance\n", osnode);
+      // if (HWLOC_SHOW_CRITICAL_ERRORS())
+      //  fprintf(stderr, "hwloc/linux: node P#%u cpuset intersects with previous nodes, forcing its acceptance\n", osnode);
     }
     hwloc_bitmap_or(nodes_cpuset, nodes_cpuset, cpuset);
 
@@ -4210,7 +4210,7 @@
 	  cur_obj = tree;
 	  cur_type = cur_obj->type;
 	  tree = cur_obj->memory_first_child;
-	  assert(!cur_obj->next_sibling);
+         //assert(!cur_obj->next_sibling);
 	  res_obj = hwloc__insert_object_by_cpuset(topology, NULL, cur_obj, "linux:sysfs:numa");
 	  if (res_obj != cur_obj && cur_type == HWLOC_OBJ_NUMANODE) {
 	    /* This NUMA node got merged somehow, could be a buggy BIOS reporting wrong NUMA node cpuset.
@@ -4362,7 +4362,7 @@
     if (cpukinds->sets[first].value == value)
       break;
   /* it must exist since we're downgrading some values to an existing one */
-  assert(first < cpukinds->nr_sets);
+  //assert(first < cpukinds->nr_sets);
 
   /* merge affected sets with the existing one */
   for(i=0; i<cpukinds->nr_sets; i++) {
@@ -4466,12 +4466,12 @@
   hwloc_bitmap_foreach_begin(i, topology->levels[0][0]->cpuset) {
     unsigned maxfreq = 0, basefreq = 0;
     /* cpuinfo_max_freq is the hardware max. scaling_max_freq is the software policy current max */
-    sprintf(str, "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", i);
+    snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", i);
     if (hwloc_read_path_as_uint(str, &maxfreq, data->root_fd) >= 0)
       if (maxfreq)
         hwloc_linux_cpukinds_add(&cpufreqs_max, i, maxfreq/1000);
     /* base_frequency is intel_pstate specific */
-    sprintf(str, "/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency", i);
+    snprintf(str, 53, "/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency", i);
     if (hwloc_read_path_as_uint(str, &basefreq, data->root_fd) >= 0)
       if (basefreq)
         hwloc_linux_cpukinds_add(&cpufreqs_base, i, basefreq/1000);
@@ -4494,7 +4494,7 @@
   hwloc_linux_cpukinds_init(&cpu_capacity);
   hwloc_bitmap_foreach_begin(i, topology->levels[0][0]->cpuset) {
     unsigned capacity;
-    sprintf(str, "/sys/devices/system/cpu/cpu%d/cpu_capacity", i);
+    snprintf(str, 43, "/sys/devices/system/cpu/cpu%d/cpu_capacity", i);
     if (hwloc_read_path_as_uint(str, &capacity, data->root_fd) >= 0)
       hwloc_linux_cpukinds_add(&cpu_capacity, i, capacity);
   } hwloc_bitmap_foreach_end();
@@ -4566,7 +4566,7 @@
 	}
       } else {
 	/* /sys/devices/system/cpu/online unavailable, check the cpu online file */
-	sprintf(str, "/sys/devices/system/cpu/cpu%lu/online", cpu);
+       snprintf(str, 38, "/sys/devices/system/cpu/cpu%lu/online", cpu);
 	if (hwloc_read_path_by_length(str, online, sizeof(online), data->root_fd) > 0) {
 	  if (!atoi(online)) {
 	    hwloc_debug("os proc %lu is offline\n", cpu);
@@ -4576,7 +4576,7 @@
       }
 
       /* check whether the kernel exports topology information for this cpu */
-      sprintf(str, "/sys/devices/system/cpu/cpu%lu/topology", cpu);
+      snprintf(str, 40, "/sys/devices/system/cpu/cpu%lu/topology", cpu);
       if (hwloc_access(str, X_OK, data->root_fd) < 0 && errno == ENOENT) {
 	hwloc_debug("os proc %lu has no accessible /sys/devices/system/cpu/cpu%lu/topology\n",
 		   cpu, cpu);
@@ -4608,9 +4608,9 @@
       /* look at the core */
       hwloc_bitmap_t coreset;
       if (old_filenames)
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
+       snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
       else
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
+       snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
       coreset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (coreset) {
         unsigned mycoreid = (unsigned) -1;
@@ -4621,7 +4621,7 @@
 	  unsigned siblingid, siblingcoreid;
 
 	  mycoreid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
+         snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	    mycoreid = (unsigned) tmpint;
 	  gotcoreid = 1;
@@ -4630,7 +4630,7 @@
 	  if (siblingid == (unsigned) i)
 	    siblingid = hwloc_bitmap_next(coreset, i);
 	  siblingcoreid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%u/topology/core_id", siblingid); /* contains %d at least up to 4.19 */
+         snprintf(str, 47, "/sys/devices/system/cpu/cpu%u/topology/core_id", siblingid); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	    siblingcoreid = (unsigned) tmpint;
 	  threadwithcoreid = (siblingcoreid != mycoreid);
@@ -4643,7 +4643,7 @@
 
 	  if (!gotcoreid) {
 	    mycoreid = (unsigned) -1;
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
+           snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
 	    if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	      mycoreid = (unsigned) tmpint;
 	  }
@@ -4666,7 +4666,7 @@
     if (!notfirstofcore /* don't look at the cluster unless we are the first of the core */
 	&& hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
       /* look at the cluster */
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/cluster_cpus", i);
+      snprintf(str, 52, "/sys/devices/system/cpu/cpu%d/topology/cluster_cpus", i);
       clusterset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (clusterset) {
 	hwloc_bitmap_and(clusterset, clusterset, cpuset);
@@ -4690,7 +4690,7 @@
     if (!notfirstofcluster /* don't look at the die unless we are the first of the core */
 	&& hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_DIE)) {
       /* look at the die */
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/die_cpus", i);
+      snprintf(str, 48, "/sys/devices/system/cpu/cpu%d/topology/die_cpus", i);
       dieset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (dieset) {
 	hwloc_bitmap_and(dieset, dieset, cpuset);
@@ -4718,9 +4718,9 @@
       /* look at the package */
       hwloc_bitmap_t packageset;
       if (old_filenames)
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_siblings", i);
+       snprintf(str, 53, "/sys/devices/system/cpu/cpu%d/topology/core_siblings", i);
       else
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/package_cpus", i);
+       snprintf(str, 52, "/sys/devices/system/cpu/cpu%d/topology/package_cpus", i);
       packageset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (packageset) {
 	hwloc_bitmap_and(packageset, packageset, cpuset);
@@ -4739,7 +4739,7 @@
 	  struct hwloc_obj *package;
 	  unsigned mypackageid;
 	  mypackageid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id", i); /* contains %d at least up to 4.19 */
+         snprintf(str, 59, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id", i); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	    mypackageid = (unsigned) tmpint;
 
@@ -4766,7 +4766,7 @@
       struct hwloc_obj *cluster;
       unsigned myclusterid;
       myclusterid = (unsigned) -1;
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/cluster_id", i); /* contains %d when added in 5.16 */
+      snprintf(str, 50, "/sys/devices/system/cpu/cpu%d/topology/cluster_id", i); /* contains %d when added in 5.16 */
       if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	myclusterid = (unsigned) tmpint;
 
@@ -4784,7 +4784,7 @@
       struct hwloc_obj *die;
       unsigned mydieid;
       mydieid = (unsigned) -1;
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/die_id", i); /* contains %d when added in 5.2 */
+      snprintf(str, 46, "/sys/devices/system/cpu/cpu%d/topology/die_id", i); /* contains %d when added in 5.2 */
       if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	mydieid = (unsigned) tmpint;
 
@@ -4799,7 +4799,7 @@
 	&& hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
       /* look at the books */
       hwloc_bitmap_t bookset, drawerset;
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/book_siblings", i);
+      snprintf(str, 53, "/sys/devices/system/cpu/cpu%d/topology/book_siblings", i);
       bookset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (bookset) {
 	hwloc_bitmap_and(bookset, bookset, cpuset);
@@ -4807,7 +4807,7 @@
 	  struct hwloc_obj *book;
 	  unsigned mybookid;
 	  mybookid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/book_id", i); /* contains %d at least up to 4.19 */
+         snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/topology/book_id", i); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0) {
 	    mybookid = (unsigned) tmpint;
 
@@ -4824,7 +4824,7 @@
         }
 	hwloc_bitmap_free(bookset);
 
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/drawer_siblings", i);
+       snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/topology/drawer_siblings", i);
 	drawerset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
 	if (drawerset) {
 	  hwloc_bitmap_and(drawerset, drawerset, cpuset);
@@ -4832,7 +4832,7 @@
 	    struct hwloc_obj *drawer;
 	    unsigned mydrawerid;
 	    mydrawerid = (unsigned) -1;
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/drawer_id", i); /* contains %d at least up to 4.19 */
+           snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/topology/drawer_id", i); /* contains %d at least up to 4.19 */
 	    if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0) {
 	      mydrawerid = (unsigned) tmpint;
 
@@ -4870,16 +4870,16 @@
       char str2[20]; /* enough for a level number (one digit) or a type (Data/Instruction/Unified) */
       hwloc_bitmap_t cacheset;
 
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/shared_cpu_map", i, j);
+      snprintf(str, 59, "/sys/devices/system/cpu/cpu%d/cache/index%d/shared_cpu_map", i, j);
       cacheset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (cacheset) {
 	if (hwloc_bitmap_iszero(cacheset)) {
 	  /* ia64 returning empty L3 and L2i? use the core set instead */
 	  hwloc_bitmap_t tmpset;
 	  if (old_filenames)
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
+           snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
 	  else
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
+           snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
 	  tmpset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
 	  /* only use it if we actually got something */
 	  if (tmpset) {
@@ -4900,14 +4900,14 @@
 	  struct hwloc_obj *cache;
 
 	  /* get the cache level depth */
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/level", i, j); /* contains %u at least up to 4.19 */
+         snprintf(str, 50, "/sys/devices/system/cpu/cpu%d/cache/index%d/level", i, j); /* contains %u at least up to 4.19 */
 	  if (hwloc_read_path_as_uint(str, &depth, data->root_fd) < 0) {
 	    hwloc_bitmap_free(cacheset);
 	    continue;
 	  }
 
 	  /* cache type */
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/type", i, j);
+         snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/cache/index%d/type", i, j);
 	  if (hwloc_read_path_by_length(str, str2, sizeof(str2), data->root_fd) > 0) {
 	    if (!strncmp(str2, "Data", 4))
 	      ctype = HWLOC_OBJ_CACHE_DATA;
@@ -4918,7 +4918,7 @@
 	  }
 
           /* cache id */
-          sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/id", i, j);
+          snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/cache/index%d/id", i, j);
           hwloc_read_path_as_uint(str, &id, data->root_fd);
 
 	  otype = hwloc_cache_type_by_depth_type(depth, ctype);
@@ -4933,7 +4933,7 @@
 
 	  /* get the cache size */
 	  kB = 0;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/size", i, j); /* contains %uK at least up to 4.19 */
+         snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/cache/index%d/size", i, j); /* contains %uK at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &kB, data->root_fd);
 	  /* KNL reports L3 with size=0 and full cpuset in cpuid.
 	   * Let hwloc_linux_try_add_knl_mcdram_cache() detect it better.
@@ -4945,7 +4945,7 @@
 
 	  /* get the line size */
 	  linesize = 0;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/coherency_line_size", i, j); /* contains %u at least up to 4.19 */
+         snprintf(str, 64, "/sys/devices/system/cpu/cpu%d/cache/index%d/coherency_line_size", i, j); /* contains %u at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &linesize, data->root_fd);
 
 	  /* get the number of sets and lines per tag.
@@ -4953,11 +4953,11 @@
 	   * some archs (ia64, ppc) put 0 there when fully-associative, while others (x86) put something like -1 there.
 	   */
 	  sets = 0;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/number_of_sets", i, j); /* contains %u at least up to 4.19 */
+         snprintf(str, 59, "/sys/devices/system/cpu/cpu%d/cache/index%d/number_of_sets", i, j); /* contains %u at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &sets, data->root_fd);
 
 	  lines_per_tag = 1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/physical_line_partition", i, j); /* contains %u at least up to 4.19 */
+         snprintf(str, 68, "/sys/devices/system/cpu/cpu%d/cache/index%d/physical_line_partition", i, j); /* contains %u at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &lines_per_tag, data->root_fd);
 
 	  /* first cpu in this cache, add the cache */
@@ -5577,8 +5577,8 @@
   hwloc_debug("Found sysfs cpu files under /sys/devices/system/cpu with %s topology filenames\n",
 	      old_siblings_filenames ? "old" : "new");
   if (err < 0) {
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: failed to find sysfs cpu topology directory, aborting linux discovery.\n");
+    // if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: failed to find sysfs cpu topology directory, aborting linux discovery.\n");
     return -1;
   }
 
@@ -6796,9 +6796,9 @@
     }
     /* couldn't read a single full string from that buffer, we're screwed */
     if (!boff) {
-      if (HWLOC_SHOW_CRITICAL_ERRORS())
-        fprintf(stderr, "hwloc/linux: hwloc could read a DMI firmware entry #%u in %s\n",
-                i, path);
+      // if (HWLOC_SHOW_CRITICAL_ERRORS())
+        // fprintf(stderr, "hwloc/linux: hwloc could read a DMI firmware entry #%u in %s\n",
+        //        i, path);
       break;
     }
     /* reread buffer after previous string */
@@ -6914,8 +6914,8 @@
 #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
     if (domain > 0xffff) {
       static int warned = 0;
-      if (!warned && HWLOC_SHOW_ALL_ERRORS())
-	fprintf(stderr, "hwloc/linux: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
+    //  if (!warned && HWLOC_SHOW_ALL_ERRORS())
+	// fprintf(stderr, "hwloc/linux: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
       warned = 1;
       continue;
     }
@@ -7254,8 +7254,8 @@
       goto out_with_data;
     }
 #else
-    if (HWLOC_SHOW_CRITICAL_ERRORS())
-      fprintf(stderr, "hwloc/linux: Cannot change fsroot without openat() support.\n");
+    // if (HWLOC_SHOW_CRITICAL_ERRORS())
+    //  fprintf(stderr, "hwloc/linux: Cannot change fsroot without openat() support.\n");
     errno = ENOSYS;
     goto out_with_data;
 #endif
