Index: hwloc/topology-linux.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hwloc/topology-linux.c b/hwloc/topology-linux.c
--- a/hwloc/topology-linux.c	(revision f262ce42ff5a007a8f247b546a6fc322b2922d1e)
+++ b/hwloc/topology-linux.c	(date 1699071121253)
@@ -20,7 +20,7 @@
 #include <stdio.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <assert.h>
+//#include <assert.h>
 #ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
@@ -1431,7 +1431,7 @@
      size_t setsize;

      last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);
-     assert (last != -1);
+     //assert (last != -1);

      setsize = CPU_ALLOC_SIZE(last+1);
      plinux_set = CPU_ALLOC(last+1);
@@ -1722,7 +1722,7 @@

 #ifdef HWLOC_DEBUG
   /* max_os_index comes from hwloc_linux_find_kernel_max_numnodes() so it's a multiple of HWLOC_BITS_PER_LONG */
-  assert(!(max_os_index%HWLOC_BITS_PER_LONG));
+  //assert(!(max_os_index%HWLOC_BITS_PER_LONG));
 #endif

   hwloc_bitmap_zero(nodeset);
@@ -2588,7 +2588,7 @@
   uint64_t remaining_local_memory;
   int err;

-  sprintf(path, "/sys/devices/system/node/node%d/hugepages", node);
+  snprintf(path, 42, "/sys/devices/system/node/node%d/hugepages", node);
   err = hwloc_stat(path, &st, data->root_fd);
   if (!err) {
     types = 1 /* normal non-huge size */ + st.st_nlink - 2 /* ignore . and .. */;
@@ -2610,7 +2610,7 @@
   memory->page_types_len = 1; /* we'll increase it when successfully getting hugepage info */

   /* get the total memory */
-  sprintf(meminfopath, "/sys/devices/system/node/node%d/meminfo", node);
+  snprintf(meminfopath, 40, "/sys/devices/system/node/node%d/meminfo", node);
   hwloc_parse_meminfo_info(data, meminfopath,
 			   &memory->local_memory);
   remaining_local_memory = memory->local_memory;
@@ -2646,7 +2646,7 @@

     /* Linux nodeX/distance file contains distance from X to other localities (from ACPI SLIT table or so),
      * store them in slots X*N...X*N+N-1 */
-    sprintf(distancepath, "/sys/devices/system/node/node%u/distance", osnode);
+    snprintf(distancepath, 41, "/sys/devices/system/node/node%u/distance", osnode);
     if (hwloc_read_path_by_length(distancepath, string, len, fsroot_fd) <= 0)
       goto out_with_string;
@@ -3568,10 +3568,10 @@
    * access0 contains the fastest of GI and CPU. access1 contains the fastest of CPU.
    * Try access1 to avoid GI if any, or fallback to access0 otherwise.
    */
-  sprintf(accesspath, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
+  snprintf(accesspath, 51, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
   dir = hwloc_opendir(accesspath, data->root_fd);
   if (!dir) {
-    sprintf(accesspath, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
+    snprintf(accesspath, 51, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
     dir = hwloc_opendir(accesspath, data->root_fd);
     if (!dir)
       return -1;
@@ -3610,20 +3610,20 @@
    * access0 contains the fastest of GI and CPU. access1 contains the fastest of CPU.
    * Try access1 to avoid GI if any, or fallback to access0 otherwise.
    */
-  sprintf(accessdirpath, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
+  snprintf(accessdirpath, 51, "/sys/devices/system/node/node%u/access1/initiators", node->os_index);
   if (hwloc_access(accessdirpath, X_OK, data->root_fd) < 0)
-    sprintf(accessdirpath, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);
+    snprintf(accessdirpath, 51, "/sys/devices/system/node/node%u/access0/initiators", node->os_index);

   loc.type = HWLOC_LOCATION_TYPE_CPUSET;
   loc.location.cpuset = node->cpuset;

   /* bandwidth in MiB/s and latency in ns, just like in our memattrs API */

-  sprintf(accesspath, "%s/read_bandwidth", accessdirpath);
+  snprintf(accesspath, 18, "%s/read_bandwidth", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &rbw, data->root_fd) == 0 && rbw > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_READ_BANDWIDTH, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, rbw);
   }
-  sprintf(accesspath, "%s/write_bandwidth", accessdirpath);
+  snprintf(accesspath, 19, "%s/write_bandwidth", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &wbw, data->root_fd) == 0 && wbw > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_WRITE_BANDWIDTH, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, wbw);
   }
@@ -3631,11 +3631,11 @@
   if (rbw > 0 && wbw > 0)
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_BANDWIDTH, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, (rbw+wbw)/2);

-  sprintf(accesspath, "%s/read_latency", accessdirpath);
+  snprintf(accesspath, 16, "%s/read_latency", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &rlat, data->root_fd) == 0 && rlat > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_READ_LATENCY, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, rlat);
   }
-  sprintf(accesspath, "%s/write_latency", accessdirpath);
+  snprintf(accesspath, 17, "%s/write_latency", accessdirpath);
   if (hwloc_read_path_as_uint(accesspath, &wlat, data->root_fd) == 0 && wlat > 0) {
     hwloc_internal_memattr_set_value(topology, HWLOC_MEMATTR_ID_WRITE_LATENCY, HWLOC_OBJ_NUMANODE, (hwloc_uint64_t)-1, node->os_index, &loc, wlat);
   }
@@ -3660,7 +3660,7 @@
   DIR *mscdir;
   struct dirent *dirent;

-  sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache", osnode);
+  snprintf(mscpath, 50, "/sys/devices/system/node/node%u/memory_side_cache", osnode);
   mscdir = hwloc_opendir(mscpath, data->root_fd);
   if (!mscdir)
     return -1;
@@ -3677,15 +3677,15 @@

     depth = atoi(dirent->d_name+5);

-    sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache/index%u/size", osnode, depth);
+    snprintf(mscpath, 63, "/sys/devices/system/node/node%u/memory_side_cache/index%u/size", osnode, depth);
     if (hwloc_read_path_as_uint64(mscpath, &size, data->root_fd) < 0)
       continue;

-    sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache/index%u/line_size", osnode, depth);
+    snprintf(mscpath, 68, "/sys/devices/system/node/node%u/memory_side_cache/index%u/line_size", osnode, depth);
     if (hwloc_read_path_as_uint(mscpath, &line_size, data->root_fd) < 0)
       continue;

-    sprintf(mscpath, "/sys/devices/system/node/node%u/memory_side_cache/index%u/indexing", osnode, depth);
+    snprintf(mscpath, 67, "/sys/devices/system/node/node%u/memory_side_cache/index%u/indexing", osnode, depth);
     if (hwloc_read_path_as_uint(mscpath, &associativity, data->root_fd) < 0)
       continue;
     /* 0 for direct-mapped, 1 for indexed (don't know how many ways), 2 for custom/other */
@@ -3864,7 +3864,7 @@
   }
   closedir(dir);

-  assert(nbnodes >= 1); /* linux cannot have a "node/" subdirectory without at least one "node%d" */
+  //assert(nbnodes >= 1); /* linux cannot have a "node/" subdirectory without at least one "node%d" */

   /* we don't know if sysfs returns nodes in order, we can't merge above and below loops */
@@ -3835,7 +3835,7 @@
   nodeset = hwloc__alloc_read_path_as_cpulist("/sys/devices/system/node/online", data->root_fd);
   if (nodeset) {
     int _nbnodes = hwloc_bitmap_weight(nodeset);
-    assert(_nbnodes >= 1);
+    //assert(_nbnodes >= 1);
     nbnodes = (unsigned)_nbnodes;
     hwloc_debug_bitmap("possible NUMA nodes %s\n", nodeset);
     goto found;
@@ -3942,7 +3942,7 @@
   for(node=hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, NULL);
       node != NULL;
       node = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, node)) {
-    assert(node); /* list_sysfsnode() ensured that sysfs nodes and existing nodes match */
+    //assert(node); /* list_sysfsnode() ensured that sysfs nodes and existing nodes match */

     /* hwloc_parse_nodes_distances() requires nodes in physical index order,
      * and inserting distances requires nodes[] and indexes[] in same order.
@@ -4028,7 +4028,7 @@
     hwloc_bitmap_t cpuset;

     osnode = indexes[i];
-    sprintf(nodepath, "/sys/devices/system/node/node%u/cpumap", osnode);
+    snprintf(nodepath, 39, "/sys/devices/system/node/node%u/cpumap", osnode);
     cpuset = hwloc__alloc_read_path_as_cpumask(nodepath, data->root_fd);
     if (!cpuset) {
       /* This NUMA object won't be inserted, we'll ignore distances */
@@ -4210,7 +4210,7 @@
 	  cur_obj = tree;
 	  cur_type = cur_obj->type;
 	  tree = cur_obj->memory_first_child;
-	  assert(!cur_obj->next_sibling);
+	  //assert(!cur_obj->next_sibling);
 	  res_obj = hwloc__insert_object_by_cpuset(topology, NULL, cur_obj, "linux:sysfs:numa");
 	  if (res_obj != cur_obj && cur_type == HWLOC_OBJ_NUMANODE) {
 	    /* This NUMA node got merged somehow, could be a buggy BIOS reporting wrong NUMA node cpuset.
@@ -4362,7 +4362,7 @@
     if (cpukinds->sets[first].value == value)
       break;
   /* it must exist since we're downgrading some values to an existing one */
-  assert(first < cpukinds->nr_sets);
+  //assert(first < cpukinds->nr_sets);

   /* merge affected sets with the existing one */
   for(i=0; i<cpukinds->nr_sets; i++) {
@@ -4466,12 +4466,12 @@
   hwloc_bitmap_foreach_begin(i, topology->levels[0][0]->cpuset) {
     unsigned maxfreq = 0, basefreq = 0;
     /* cpuinfo_max_freq is the hardware max. scaling_max_freq is the software policy current max */
-    sprintf(str, "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", i);
+    snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", i);
     if (hwloc_read_path_as_uint(str, &maxfreq, data->root_fd) >= 0)
       if (maxfreq)
         hwloc_linux_cpukinds_add(&cpufreqs_max, i, maxfreq/1000);
     /* base_frequency is intel_pstate specific */
-    sprintf(str, "/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency", i);
+    snprintf(str, 53, "/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency", i);
     if (hwloc_read_path_as_uint(str, &basefreq, data->root_fd) >= 0)
       if (basefreq)
         hwloc_linux_cpukinds_add(&cpufreqs_base, i, basefreq/1000);
@@ -4494,7 +4494,7 @@
   hwloc_linux_cpukinds_init(&cpu_capacity);
   hwloc_bitmap_foreach_begin(i, topology->levels[0][0]->cpuset) {
     unsigned capacity;
-    sprintf(str, "/sys/devices/system/cpu/cpu%d/cpu_capacity", i);
+    snprintf(str, 43, "/sys/devices/system/cpu/cpu%d/cpu_capacity", i);
     if (hwloc_read_path_as_uint(str, &capacity, data->root_fd) >= 0)
       hwloc_linux_cpukinds_add(&cpu_capacity, i, capacity);
   } hwloc_bitmap_foreach_end();
@@ -4566,7 +4566,7 @@
 	}
       } else {
 	/* /sys/devices/system/cpu/online unavailable, check the cpu online file */
-	sprintf(str, "/sys/devices/system/cpu/cpu%lu/online", cpu);
+	snprintf(str, 38, "/sys/devices/system/cpu/cpu%lu/online", cpu);
 	if (hwloc_read_path_by_length(str, online, sizeof(online), data->root_fd) > 0) {
 	  if (!atoi(online)) {
 	    hwloc_debug("os proc %lu is offline\n", cpu);
@@ -4576,7 +4576,7 @@
       }

       /* check whether the kernel exports topology information for this cpu */
-      sprintf(str, "/sys/devices/system/cpu/cpu%lu/topology", cpu);
+      snprintf(str, 40, "/sys/devices/system/cpu/cpu%lu/topology", cpu);
       if (hwloc_access(str, X_OK, data->root_fd) < 0 && errno == ENOENT) {
 	hwloc_debug("os proc %lu has no accessible /sys/devices/system/cpu/cpu%lu/topology\n",
 		   cpu, cpu);
@@ -4608,9 +4608,9 @@
       /* look at the core */
       hwloc_bitmap_t coreset;
       if (old_filenames)
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
+	snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
       else
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
+	snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
       coreset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (coreset) {
         unsigned mycoreid = (unsigned) -1;
@@ -4621,7 +4621,7 @@
 	  unsigned siblingid, siblingcoreid;

 	  mycoreid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
+	  snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	    mycoreid = (unsigned) tmpint;
 	  gotcoreid = 1;
@@ -4630,7 +4630,7 @@
 	  if (siblingid == (unsigned) i)
 	    siblingid = hwloc_bitmap_next(coreset, i);
 	  siblingcoreid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%u/topology/core_id", siblingid); /* contains %d at least up to 4.19 */
+	  snprintf(str, 47, "/sys/devices/system/cpu/cpu%u/topology/core_id", siblingid); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	    siblingcoreid = (unsigned) tmpint;
 	  threadwithcoreid = (siblingcoreid != mycoreid);
@@ -4643,7 +4643,7 @@

 	  if (!gotcoreid) {
 	    mycoreid = (unsigned) -1;
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
+	    snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/topology/core_id", i); /* contains %d at least up to 4.19 */
 	    if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	      mycoreid = (unsigned) tmpint;
 	  }
@@ -4666,7 +4666,7 @@
     if (!notfirstofcore /* don't look at the cluster unless we are the first of the core */
 	&& hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
       /* look at the cluster */
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/cluster_cpus", i);
+      snprintf(str, 52, "/sys/devices/system/cpu/cpu%d/topology/cluster_cpus", i);
       clusterset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (clusterset) {
 	hwloc_bitmap_and(clusterset, clusterset, cpuset);
@@ -4690,7 +4690,7 @@
     if (!notfirstofcluster /* don't look at the die unless we are the first of the core */
 	&& hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_DIE)) {
       /* look at the die */
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/die_cpus", i);
+      snprintf(str, 48, "/sys/devices/system/cpu/cpu%d/topology/die_cpus", i);
       dieset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (dieset) {
 	hwloc_bitmap_and(dieset, dieset, cpuset);
@@ -4718,9 +4718,9 @@
       /* look at the package */
       hwloc_bitmap_t packageset;
       if (old_filenames)
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_siblings", i);
+	snprintf(str, 53, "/sys/devices/system/cpu/cpu%d/topology/core_siblings", i);
       else
-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/package_cpus", i);
+	snprintf(str, 52, "/sys/devices/system/cpu/cpu%d/topology/package_cpus", i);
       packageset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (packageset) {
 	hwloc_bitmap_and(packageset, packageset, cpuset);
@@ -4739,7 +4739,7 @@
 	  struct hwloc_obj *package;
 	  unsigned mypackageid;
 	  mypackageid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id", i); /* contains %d at least up to 4.19 */
+	  snprintf(str, 59, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id", i); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	    mypackageid = (unsigned) tmpint;

@@ -4766,7 +4766,7 @@
       struct hwloc_obj *cluster;
       unsigned myclusterid;
       myclusterid = (unsigned) -1;
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/cluster_id", i); /* contains %d when added in 5.16 */
+      snprintf(str, 50, "/sys/devices/system/cpu/cpu%d/topology/cluster_id", i); /* contains %d when added in 5.16 */
       if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	myclusterid = (unsigned) tmpint;

@@ -4784,7 +4784,7 @@
       struct hwloc_obj *die;
       unsigned mydieid;
       mydieid = (unsigned) -1;
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/die_id", i); /* contains %d when added in 5.2 */
+      snprintf(str, 46, "/sys/devices/system/cpu/cpu%d/topology/die_id", i); /* contains %d when added in 5.2 */
       if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0)
 	mydieid = (unsigned) tmpint;

@@ -4799,7 +4799,7 @@
 	&& hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
       /* look at the books */
       hwloc_bitmap_t bookset, drawerset;
-      sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/book_siblings", i);
+      snprintf(str, 53, "/sys/devices/system/cpu/cpu%d/topology/book_siblings", i);
       bookset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (bookset) {
 	hwloc_bitmap_and(bookset, bookset, cpuset);
@@ -4807,7 +4807,7 @@
 	  struct hwloc_obj *book;
 	  unsigned mybookid;
 	  mybookid = (unsigned) -1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/book_id", i); /* contains %d at least up to 4.19 */
+	  snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/topology/book_id", i); /* contains %d at least up to 4.19 */
 	  if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0) {
 	    mybookid = (unsigned) tmpint;

@@ -4824,7 +4824,7 @@
         }
 	hwloc_bitmap_free(bookset);

-	sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/drawer_siblings", i);
+	snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/topology/drawer_siblings", i);
 	drawerset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
 	if (drawerset) {
 	  hwloc_bitmap_and(drawerset, drawerset, cpuset);
@@ -4832,7 +4832,7 @@
 	    struct hwloc_obj *drawer;
 	    unsigned mydrawerid;
 	    mydrawerid = (unsigned) -1;
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/drawer_id", i); /* contains %d at least up to 4.19 */
+	    snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/topology/drawer_id", i); /* contains %d at least up to 4.19 */
 	    if (hwloc_read_path_as_int(str, &tmpint, data->root_fd) == 0) {
 	      mydrawerid = (unsigned) tmpint;

@@ -4870,16 +4870,16 @@
       char str2[20]; /* enough for a level number (one digit) or a type (Data/Instruction/Unified) */
       hwloc_bitmap_t cacheset;

-      sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/shared_cpu_map", i, j);
+      snprintf(str, 59, "/sys/devices/system/cpu/cpu%d/cache/index%d/shared_cpu_map", i, j);
       cacheset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
       if (cacheset) {
 	if (hwloc_bitmap_iszero(cacheset)) {
 	  /* ia64 returning empty L3 and L2i? use the core set instead */
 	  hwloc_bitmap_t tmpset;
 	  if (old_filenames)
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
+	    snprintf(str, 55, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
 	  else
-	    sprintf(str, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
+	    snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/topology/core_cpus", i);
 	  tmpset = hwloc__alloc_read_path_as_cpumask(str, data->root_fd);
 	  /* only use it if we actually got something */
 	  if (tmpset) {
@@ -4900,14 +4900,14 @@
 	  struct hwloc_obj *cache;

 	  /* get the cache level depth */
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/level", i, j); /* contains %u at least up to 4.19 */
+	  snprintf(str, 50, "/sys/devices/system/cpu/cpu%d/cache/index%d/level", i, j); /* contains %u at least up to 4.19 */
 	  if (hwloc_read_path_as_uint(str, &depth, data->root_fd) < 0) {
 	    hwloc_bitmap_free(cacheset);
 	    continue;
 	  }

 	  /* cache type */
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/type", i, j);
+	  snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/cache/index%d/type", i, j);
 	  if (hwloc_read_path_by_length(str, str2, sizeof(str2), data->root_fd) > 0) {
 	    if (!strncmp(str2, "Data", 4))
 	      ctype = HWLOC_OBJ_CACHE_DATA;
@@ -4918,7 +4918,7 @@
 	  }

           /* cache id */
-          sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/id", i, j);
+          snprintf(str, 47, "/sys/devices/system/cpu/cpu%d/cache/index%d/id", i, j);
           hwloc_read_path_as_uint(str, &id, data->root_fd);

 	  otype = hwloc_cache_type_by_depth_type(depth, ctype);
@@ -4933,7 +4933,7 @@

 	  /* get the cache size */
 	  kB = 0;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/size", i, j); /* contains %uK at least up to 4.19 */
+	  snprintf(str, 49, "/sys/devices/system/cpu/cpu%d/cache/index%d/size", i, j); /* contains %uK at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &kB, data->root_fd);
 	  /* KNL reports L3 with size=0 and full cpuset in cpuid.
 	   * Let hwloc_linux_try_add_knl_mcdram_cache() detect it better.
@@ -4945,7 +4945,7 @@

 	  /* get the line size */
 	  linesize = 0;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/coherency_line_size", i, j); /* contains %u at least up to 4.19 */
+	  snprintf(str, 64, "/sys/devices/system/cpu/cpu%d/cache/index%d/coherency_line_size", i, j); /* contains %u at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &linesize, data->root_fd);

 	  /* get the number of sets and lines per tag.
@@ -4953,11 +4953,11 @@
 	   * some archs (ia64, ppc) put 0 there when fully-associative, while others (x86) put something like -1 there.
 	   */
 	  sets = 0;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/number_of_sets", i, j); /* contains %u at least up to 4.19 */
+	  snprintf(str, 59, "/sys/devices/system/cpu/cpu%d/cache/index%d/number_of_sets", i, j); /* contains %u at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &sets, data->root_fd);

 	  lines_per_tag = 1;
-	  sprintf(str, "/sys/devices/system/cpu/cpu%d/cache/index%d/physical_line_partition", i, j); /* contains %u at least up to 4.19 */
+	  snprintf(str, 68, "/sys/devices/system/cpu/cpu%d/cache/index%d/physical_line_partition", i, j); /* contains %u at least up to 4.19 */
 	  hwloc_read_path_as_uint(str, &lines_per_tag, data->root_fd);

 	  /* first cpu in this cache, add the cache */

