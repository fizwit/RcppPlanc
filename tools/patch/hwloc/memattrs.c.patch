Subject: [PATCH] memattrs.c.patch
---
Index: hwloc/memattrs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hwloc/memattrs.c b/hwloc/memattrs.c
--- a/hwloc/memattrs.c	(revision f262ce42ff5a007a8f247b546a6fc322b2922d1e)
+++ b/hwloc/memattrs.c	(date 1699468337392)
@@ -21,8 +21,8 @@
     return node->attr->numanode.local_memory;
   else if (id == HWLOC_MEMATTR_ID_LOCALITY)
     return hwloc_bitmap_weight(node->cpuset);
-  else
-    assert(0);
+  //else
+    //assert(0);
   return 0; /* shut up the compiler */
 }
 
@@ -157,10 +157,10 @@
     struct hwloc_internal_memattr_s *nimattr = &imattrs[id];
     unsigned j;
 
-    assert(oimattr->name);
+    //assert(oimattr->name);
     nimattr->name = hwloc_tma_strdup(tma, oimattr->name);
     if (!nimattr->name) {
-      assert(!tma || !tma->dontfree); /* this tma cannot fail to allocate */
+      //assert(!tma || !tma->dontfree); /* this tma cannot fail to allocate */
       new->nr_memattrs = id;
       goto failed;
     }
@@ -427,7 +427,7 @@
     return 0;
   }
   default:
-    assert(0);
+    NULL;
   }
   return -1;
 }
@@ -440,7 +440,7 @@
   hwloc_obj_t node;
 
   /* no need to refresh convenience memattrs */
-  assert(!(imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE));
+  //assert(!(imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE));
 
   /* check the target object */
   if (imtg->gp_index == (hwloc_uint64_t) -1) {
@@ -715,7 +715,7 @@
   struct hwloc_internal_memattr_initiator_s *imi;
   struct hwloc_internal_location_s iloc;
 
-  assert(imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR);
+  //assert(imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR);
 
   /* use the initiator value */
   if (!location) {
@@ -770,7 +770,7 @@
   }
 
   /* all convenience attributes have no initiators */
-  assert(!(imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE));
+  //assert(!(imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE));
 
   if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
     hwloc__imattr_refresh(topology, imattr);
@@ -784,7 +784,7 @@
   for(i=0; i<imtg->nr_initiators && i<max; i++) {
     struct hwloc_internal_memattr_initiator_s *imi = &imtg->initiators[i];
     int err = from_internal_location(&imi->initiator, &initiators[i]);
-    assert(!err);
+    //assert(!err);
     if (values)
       /* no need to handle capacity/locality special cases here, those are initiator-less attributes */
       values[i] = imi->value;
@@ -920,8 +920,8 @@
                                  struct hwloc_internal_location_s *initiator,
                                  hwloc_uint64_t value)
 {
-  assert(id != HWLOC_MEMATTR_ID_CAPACITY);
-  assert(id != HWLOC_MEMATTR_ID_LOCALITY);
+  //assert(id != HWLOC_MEMATTR_ID_CAPACITY);
+  //assert(id != HWLOC_MEMATTR_ID_LOCALITY);
 
   return hwloc__internal_memattr_set_value(topology, id, target_type, target_gp_index, target_os_index, initiator, value);
 }
@@ -1044,7 +1044,7 @@
 
  done:
   if (found) {
-    assert(best);
+    //assert(best);
     *bestp = best;
     if (valuep)
       *valuep = best_value;
@@ -1268,8 +1268,8 @@
     } else if (!strcmp(env, "spm_is_hbm")) {
       hwloc_debug("Assuming SPM-tier is HBM, ignore bandwidth\n");
       spm_is_hbm = 1;
-    } else if (HWLOC_SHOW_CRITICAL_ERRORS()) {
-      fprintf(stderr, "hwloc: Failed to recognize HWLOC_MEMTIERS_GUESS value %s\n", env);
+    //} else if (HWLOC_SHOW_CRITICAL_ERRORS()) {
+    //  fprintf(stderr, "hwloc: Failed to recognize HWLOC_MEMTIERS_GUESS value %s\n", env);
     }
   }
 
@@ -1279,7 +1279,7 @@
     hwloc__imattr_refresh(topology, imattr);
 
   n = hwloc_get_nbobjs_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE);
-  assert(n);
+  //assert(n);
 
   tiers = malloc(n * sizeof(*tiers));
   if (!tiers)
@@ -1293,7 +1293,7 @@
     struct hwloc_internal_memattr_initiator_s *imi;
 
     node = hwloc_get_obj_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE, i);
-    assert(node);
+    //assert(node);
     tiers[i].node = node;
 
     /* defaults */
