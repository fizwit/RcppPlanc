Subject: [PATCH] topology-synthetic.c.patch
---
Index: hwloc/topology-synthetic.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hwloc/topology-synthetic.c b/hwloc/topology-synthetic.c
--- a/hwloc/topology-synthetic.c        (revision f262ce42ff5a007a8f247b546a6fc322b2922d1e)
+++ b/hwloc/topology-synthetic.c        (date 1699467304023)
@@ -13,7 +13,7 @@
 #include "private/debug.h"

 #include <limits.h>
-#include <assert.h>
+//#include <assert.h>
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
 #endif
@@ -83,8 +83,8 @@

   array = calloc(total, sizeof(*array));
   if (!array) {
-    if (verbose)
-      fprintf(stderr, "Failed to allocate synthetic index array of size %lu\n", total);
+    // if (verbose)
+    //  fprintf(stderr, "Failed to allocate synthetic index array of size %lu\n", total);
     goto out;
   }

@@ -96,16 +96,16 @@
       const char *next;
       unsigned idx = strtoul(attr, (char **) &next, 10);
       if (next == attr) {
-       if (verbose)
-         fprintf(stderr, "Failed to read synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
+       // if (verbose)
+       //  fprintf(stderr, "Failed to read synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
        goto out_with_array;
       }

       array[i] = idx;
       if (i != total-1) {
        if (*next != ',') {
-         if (verbose)
-           fprintf(stderr, "Missing comma after synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
+         // if (verbose)
+         //  fprintf(stderr, "Missing comma after synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
          goto out_with_array;
        }
        attr = next+1;
@@ -148,28 +148,28 @@
        char *tmp2, *tmp3;
        step = (unsigned) strtol(tmp, &tmp2, 0);
        if (tmp2 == tmp || *tmp2 != '*') {
-         if (verbose)
-           fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number before '*'\n", tmp);
+         // if (verbose)
+         //  fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number before '*'\n", tmp);
          free(loops);
          goto out_with_array;
        }
        if (!step) {
-         if (verbose)
-           fprintf(stderr, "Invalid interleaving loop with step 0 at '%s'\n", tmp);
+         // if (verbose)
+         //  fprintf(stderr, "Invalid interleaving loop with step 0 at '%s'\n", tmp);
          free(loops);
          goto out_with_array;
        }
        tmp2++;
        nb = (unsigned) strtol(tmp2, &tmp3, 0);
        if (tmp3 == tmp2 || (*tmp3 && *tmp3 != ':' && *tmp3 != ')' && *tmp3 != ' ')) {
-         if (verbose)
-           fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number between '*' and ':'\n", tmp);
+         // if (verbose)
+         //  fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number between '*' and ':'\n", tmp);
          free(loops);
          goto out_with_array;
        }
        if (!nb) {
-         if (verbose)
-           fprintf(stderr, "Invalid interleaving loop with number 0 at '%s'\n", tmp2);
+         // if (verbose)
+         //  fprintf(stderr, "Invalid interleaving loop with number 0 at '%s'\n", tmp2);
          free(loops);
          goto out_with_array;
        }
@@ -196,14 +196,14 @@
       while (tmp) {
        err = hwloc_type_sscanf(tmp, &type, &attrs, sizeof(attrs));
        if (err < 0) {
-         if (verbose)
-           fprintf(stderr, "Failed to read synthetic index interleaving loop type '%s'\n", tmp);
+         // if (verbose)
+         //  fprintf(stderr, "Failed to read synthetic index interleaving loop type '%s'\n", tmp);
          free(loops);
          goto out_with_array;
        }
        if (type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
-         if (verbose)
-           fprintf(stderr, "Misc object type disallowed in synthetic index interleaving loop type '%s'\n", tmp);
+         // if (verbose)
+         //  fprintf(stderr, "Misc object type disallowed in synthetic index interleaving loop type '%s'\n", tmp);
          free(loops);
          goto out_with_array;
        }
@@ -222,9 +222,9 @@
          break;
        }
        if (loops[cur_loop].level_depth == (unsigned)-1) {
-         if (verbose)
-           fprintf(stderr, "Failed to find level for synthetic index interleaving loop type '%s'\n",
-                   tmp);
+         // if (verbose)
+         //  fprintf(stderr, "Failed to find level for synthetic index interleaving loop type '%s'\n",
+               //    tmp);
          free(loops);
          goto out_with_array;
        }
@@ -242,8 +242,8 @@
        unsigned step, nb;
        for(i=0; i<nr_loops; i++) {
          if (loops[i].level_depth == mydepth && i != cur_loop) {
-           if (verbose)
-             fprintf(stderr, "Invalid duplicate interleaving loop type in synthetic index '%s'\n", attr);
+           // if (verbose)
+           //  fprintf(stderr, "Invalid duplicate interleaving loop type in synthetic index '%s'\n", attr);
            free(loops);
            goto out_with_array;
          }
@@ -256,14 +256,14 @@

        loops[cur_loop].step = step;
        loops[cur_loop].nb = nb;
-       assert(nb);
-       assert(step);
+       // assert(nb);
+       // assert(step);
        if (step < minstep)
          minstep = step;
        nbs *= nb;
       }
     }
-    assert(nbs);
+    // assert(nbs);

     if (nbs != total) {
       /* one loop of total/nbs steps is missing, add it if it's just the smallest one */
@@ -272,8 +272,8 @@
        loops[nr_loops].nb = total/nbs;
        nr_loops++;
       } else {
-       if (verbose)
-         fprintf(stderr, "Invalid index interleaving total width %lu instead of %lu\n", nbs, total);
+       // if (verbose)
+       //  fprintf(stderr, "Invalid index interleaving total width %lu instead of %lu\n", nbs, total);
        free(loops);
        goto out_with_array;
       }
@@ -294,13 +294,13 @@
     /* check that we have the right values (cannot pass total, cannot give duplicate 0) */
     for(j=0; j<total; j++) {
       if (array[j] >= total) {
-       if (verbose)
-         fprintf(stderr, "Invalid index interleaving generates out-of-range index %u\n", array[j]);
+       // if (verbose)
+       //  fprintf(stderr, "Invalid index interleaving generates out-of-range index %u\n", array[j]);
        goto out_with_array;
       }
       if (!array[j] && j) {
-       if (verbose)
-         fprintf(stderr, "Invalid index interleaving generates duplicate index values\n");
+       // if (verbose)
+       // fprintf(stderr, "Invalid index interleaving generates duplicate index values\n");
        goto out_with_array;
       }
     }
@@ -365,8 +365,8 @@

   next_pos = (const char *) strchr(attrs, ')');
   if (!next_pos) {
-    if (verbose)
-      fprintf(stderr, "Missing attribute closing bracket in synthetic string doesn't have a number of objects at '%s'\n", attrs);
+    // if (verbose)
+    // fprintf(stderr, "Missing attribute closing bracket in synthetic string doesn't have a number of objects at '%s'\n", attrs);
     errno = EINVAL;
     return -1;
   }
@@ -388,15 +388,15 @@

     } else {
       size_t length = strcspn(attrs, " )");
-      fprintf(stderr, "hwloc/synthetic: Ignoring unknown attribute at '%s'\n", attrs);
+      // fprintf(stderr, "hwloc/synthetic: Ignoring unknown attribute at '%s'\n", attrs);
       attrs += length;
     }

     if (' ' == *attrs)
       attrs++;
     else if (')' != *attrs) {
-      if (verbose)
-       fprintf(stderr, "Missing parameter separator at '%s'\n", attrs);
+    //  if (verbose)
+       // fprintf(stderr, "Missing parameter separator at '%s'\n", attrs);
       errno = EINVAL;
       return -1;
     }
@@ -405,8 +405,8 @@
   sattr->memorysize = memorysize;

   if (index_string) {
-    if (sind->string && verbose)
-      fprintf(stderr, "Overwriting duplicate indexes attribute with last occurence\n");
+    // if (sind->string && verbose)
+    //  fprintf(stderr, "Overwriting duplicate indexes attribute with last occurence\n");
     sind->string = index_string;
     sind->string_length = (unsigned long)index_string_length;
   }
@@ -522,14 +522,14 @@
       pos++;

       if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {
-       if (verbose)
-         fprintf(stderr, "Synthetic string with unknown attached object type at '%s'\n", pos);
+       // if (verbose)
+       // fprintf(stderr, "Synthetic string with unknown attached object type at '%s'\n", pos);
        errno = EINVAL;
        goto error;
       }
       if (type != HWLOC_OBJ_NUMANODE) {
-       if (verbose)
-         fprintf(stderr, "Synthetic string with disallowed attached object type at '%s'\n", pos);
+       // if (verbose)
+       // fprintf(stderr, "Synthetic string with disallowed attached object type at '%s'\n", pos);
        errno = EINVAL;
        goto error;
       }
@@ -549,8 +549,8 @@

       next_pos = strchr(pos, ']');
       if (!next_pos) {
-       if (verbose)
-         fprintf(stderr,"Synthetic string doesn't have a closing `]' after attached object type at '%s'\n", pos);
+       // if (verbose)
+       // fprintf(stderr,"Synthetic string doesn't have a closing `]' after attached object type at '%s'\n", pos);
        errno = EINVAL;
        goto error;
       }
@@ -581,23 +581,23 @@
          type = HWLOC_OBJ_GROUP;
        } else {
          /* FIXME: allow generic "Cache" string? would require to deal with possibly duplicate cache levels */
-         if (verbose)
-           fprintf(stderr, "Synthetic string with unknown object type at '%s'\n", pos);
+         // if (verbose)
+         // fprintf(stderr, "Synthetic string with unknown object type at '%s'\n", pos);
          errno = EINVAL;
          goto error;
        }
       }
       if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
-       if (verbose)
-         fprintf(stderr, "Synthetic string with disallowed object type at '%s'\n", pos);
+       // if (verbose)
+       // fprintf(stderr, "Synthetic string with disallowed object type at '%s'\n", pos);
        errno = EINVAL;
        goto error;
       }

       next_pos = strchr(pos, ':');
       if (!next_pos) {
-       if (verbose)
-         fprintf(stderr,"Synthetic string doesn't have a `:' after object type at '%s'\n", pos);
+       // if (verbose)
+       // fprintf(stderr,"Synthetic string doesn't have a `:' after object type at '%s'\n", pos);
        errno = EINVAL;
        goto error;
       }
@@ -619,14 +619,14 @@
     /* number of normal children */
     item = strtoul(pos, (char **)&next_pos, 0);
     if (next_pos == pos) {
-      if (verbose)
-       fprintf(stderr,"Synthetic string doesn't have a number of objects at '%s'\n", pos);
+    // if (verbose)
+       // fprintf(stderr,"Synthetic string doesn't have a number of objects at '%s'\n", pos);
       errno = EINVAL;
       goto error;
     }
     if (!item) {
-      if (verbose)
-       fprintf(stderr,"Synthetic string with disallowed 0 number of objects at '%s'\n", pos);
+    //  if (verbose)
+       //  fprintf(stderr,"Synthetic string with disallowed 0 number of objects at '%s'\n", pos);
       errno = EINVAL;
       goto error;
     }
@@ -643,14 +643,14 @@
     }

     if (count + 1 >= HWLOC_SYNTHETIC_MAX_DEPTH) {
-      if (verbose)
-       fprintf(stderr,"Too many synthetic levels, max %d\n", HWLOC_SYNTHETIC_MAX_DEPTH);
+    //  if (verbose)
+       //  fprintf(stderr,"Too many synthetic levels, max %d\n", HWLOC_SYNTHETIC_MAX_DEPTH);
       errno = EINVAL;
       goto error;
     }
     if (item > UINT_MAX) {
-      if (verbose)
-       fprintf(stderr,"Too big arity, max %u\n", UINT_MAX);
+    //  if (verbose)
+       //  fprintf(stderr,"Too big arity, max %u\n", UINT_MAX);
       errno = EINVAL;
       goto error;
     }
@@ -660,8 +660,8 @@
   }

   if (data->level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE && data->level[count-1].attr.type != HWLOC_OBJ_PU) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot use non-PU type for last level\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot use non-PU type for last level\n");
     errno = EINVAL;
     return -1;
   }
@@ -679,43 +679,43 @@

   /* sanity checks */
   if (!type_count[HWLOC_OBJ_PU]) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string missing ending number of PUs\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string missing ending number of PUs\n");
     errno = EINVAL;
     return -1;
   } else if (type_count[HWLOC_OBJ_PU] > 1) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot have several PU levels\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot have several PU levels\n");
     errno = EINVAL;
     return -1;
   }
   if (type_count[HWLOC_OBJ_PACKAGE] > 1) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot have several package levels\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot have several package levels\n");
     errno = EINVAL;
     return -1;
   }
   if (type_count[HWLOC_OBJ_DIE] > 1) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot have several die levels\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot have several die levels\n");
     errno = EINVAL;
     return -1;
   }
   if (type_count[HWLOC_OBJ_NUMANODE] > 1) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot have several NUMA node levels\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot have several NUMA node levels\n");
     errno = EINVAL;
     return -1;
   }
   if (type_count[HWLOC_OBJ_NUMANODE] && data->numa_attached_nr) {
-    if (verbose)
-      fprintf(stderr,"Synthetic string cannot have NUMA nodes both as a level and attached\n");
+    // if (verbose)
+    // fprintf(stderr,"Synthetic string cannot have NUMA nodes both as a level and attached\n");
     errno = EINVAL;
     return -1;
   }
   if (type_count[HWLOC_OBJ_CORE] > 1) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot have several core levels\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot have several core levels\n");
     errno = EINVAL;
     return -1;
   }
@@ -727,8 +727,8 @@
       unset++;
   }
   if (unset && unset != count-2) {
-    if (verbose)
-      fprintf(stderr, "Synthetic string cannot mix unspecified and specified types for levels\n");
+    // if (verbose)
+    // fprintf(stderr, "Synthetic string cannot mix unspecified and specified types for levels\n");
     errno = EINVAL;
     return -1;
   }
@@ -813,8 +813,8 @@
   /* enforce a NUMA level */
   if (!type_count[HWLOC_OBJ_NUMANODE] && !data->numa_attached_nr) {
     /* insert a NUMA level below the automatic machine root */
-    if (verbose)
-      fprintf(stderr, "Inserting a NUMA level with a single object at depth 1\n");
+    // if (verbose)
+    // fprintf(stderr, "Inserting a NUMA level with a single object at depth 1\n");
     /* move existing levels by one */
     memmove(&data->level[2], &data->level[1], count*sizeof(struct hwloc_synthetic_level_data_s));
     data->level[1].attr.type = HWLOC_OBJ_NUMANODE;
@@ -890,7 +890,7 @@
     break;
   default:
     /* Should never happen */
-    assert(0);
+  //  assert(0);
     break;
   }
 }
@@ -921,7 +921,7 @@
   if (!attached)
     return;

-  assert(attached->attr.type == HWLOC_OBJ_NUMANODE);
+  //assert(attached->attr.type == HWLOC_OBJ_NUMANODE);

   attached_os_index = hwloc_synthetic_next_index(&data->numa_attached_indexes, HWLOC_OBJ_NUMANODE);

@@ -959,8 +959,8 @@
   hwloc_bitmap_t set;
   unsigned os_index;

-  assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
-  assert(type != HWLOC_OBJ_MACHINE);
+  //assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
+  //assert(type != HWLOC_OBJ_MACHINE);

   os_index = hwloc_synthetic_next_index(&curlevel->indexes, type);

@@ -1005,8 +1005,8 @@
   hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
   unsigned i;

-  assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
+  //assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);

-  assert(!topology->levels[0][0]->cpuset);
+  //assert(!topology->levels[0][0]->cpuset);

   hwloc_alloc_root_sets(topology->levels[0][0]);
@@ -1270,6 +1270,6 @@
       hwloc_obj_t *level;
       if (obj->depth < 0) {
-       assert(obj->depth == HWLOC_TYPE_DEPTH_NUMANODE);
+       //assert(obj->depth == HWLOC_TYPE_DEPTH_NUMANODE);
        total = topology->slevels[HWLOC_SLEVEL_NUMANODE].nbobjs;
        level = topology->slevels[HWLOC_SLEVEL_NUMANODE].objs;
       } else {
@@ -1362,8 +1362,8 @@
     /* v1: export a single NUMA child */
     if (parent->memory_arity > 1 || mchild->type != HWLOC_OBJ_NUMANODE) {
       /* not supported */
-      if (verbose)
-       fprintf(stderr, "Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n");
+    // if (verbose)
+       // fprintf(stderr, "Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n");
       errno = EINVAL;
       return -1;
     }
@@ -1389,19 +1389,19 @@
     while (numanode && numanode->type != HWLOC_OBJ_NUMANODE) {
       if (verbose) {
         static int warned = 0;
-        if (!warned)
-          fprintf(stderr, "Ignoring memory objects that are not NUMA nodes.\n");
+        // if (!warned)
+        // fprintf(stderr, "Ignoring memory objects that are not NUMA nodes.\n");
         warned = 1;
       }
       if (verbose && numanode->memory_arity > 1) {
         static int warned = 0;
-        if (!warned)
-          fprintf(stderr, "Ignoring non-first memory children at non-first level of memory hierarchy.\n");
+        // if (!warned)
+        // fprintf(stderr, "Ignoring non-first memory children at non-first level of memory hierarchy.\n");
         warned = 1;
       }
       numanode = numanode->memory_first_child;
     }
-    assert(numanode); /* there's always a numanode at the bottom of the memory tree */
+    //assert(numanode); /* there's always a numanode at the bottom of the memory tree */

     if (needprefix)
       hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
@@ -1439,7 +1439,7 @@

     idx = hwloc_bitmap_first(remaining_nodes);
     node = hwloc_get_numanode_obj_by_os_index(topology, idx);
-    assert(node);
+    //assert(node);

     first_parent = node->parent;

@@ -1448,7 +1448,7 @@
       hwloc_obj_t parent, mchild;

       parent = hwloc_get_obj_by_depth(topology, first_parent->depth, i);
-      assert(parent);
+      //assert(parent);

       /* must have same memory arity */
       if (parent->memory_arity != first_parent->memory_arity)
@@ -1515,16 +1515,16 @@
   /* TODO: flag to force all indexes, not only for PU and NUMA? */

   if (!obj->symmetric_subtree) {
-    if (verbose)
-      fprintf(stderr, "Cannot export to synthetic unless topology is symmetric (root->symmetric_subtree must be set).\n");
+    // if (verbose)
+    // fprintf(stderr, "Cannot export to synthetic unless topology is symmetric (root->symmetric_subtree must be set).\n");
     errno = EINVAL;
     return -1;
   }

   if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)
       && hwloc_check_memory_symmetric(topology) < 0) {
-    if (verbose)
-      fprintf(stderr, "Cannot export to synthetic unless memory is attached symmetrically.\n");
+    // if (verbose)
+    // fprintf(stderr, "Cannot export to synthetic unless memory is attached symmetrically.\n");
     errno = EINVAL;
     return -1;
   }
@@ -1535,16 +1535,16 @@
     signed pdepth;

     node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
-    assert(node);
-    assert(hwloc__obj_type_is_normal(node->parent->type)); /* only depth-1 memory children for now */
+    //assert(node);
+    //assert(hwloc__obj_type_is_normal(node->parent->type)); /* only depth-1 memory children for now */
     pdepth = node->parent->depth;

     while ((node = node->next_cousin) != NULL) {
-      assert(hwloc__obj_type_is_normal(node->parent->type)); /* only depth-1 memory children for now */
+      //assert(hwloc__obj_type_is_normal(node->parent->type)); /* only depth-1 memory children for now */
       if (node->parent->depth != pdepth) {
-       if (verbose)
-         fprintf(stderr, "Cannot export to synthetic v1 if memory is attached to parents at different depths.\n");
+       // if (verbose)
+       // fprintf(stderr, "Cannot export to synthetic v1 if memory is attached to parents at different depths.\n");
        errno = EINVAL;
        return -1;
       }

