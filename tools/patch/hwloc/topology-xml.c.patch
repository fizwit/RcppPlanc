Subject: [PATCH] topology-xml.c.patch
---
Index: hwloc/topology-xml.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hwloc/topology-xml.c b/hwloc/topology-xml.c
--- a/hwloc/topology-xml.c	(revision f262ce42ff5a007a8f247b546a6fc322b2922d1e)
+++ b/hwloc/topology-xml.c	(date 1699470368747)
@@ -119,20 +119,20 @@
     obj->os_index = strtoul(value, NULL, 10);
   else if (!strcmp(name, "gp_index")) {
     obj->gp_index = strtoull(value, NULL, 10);
-    if (!obj->gp_index && hwloc__xml_verbose())
-      fprintf(stderr, "%s: unexpected zero gp_index, topology may be invalid\n", state->global->msgprefix);
+    // if (!obj->gp_index && hwloc__xml_verbose())
+    // fprintf(stderr, "%s: unexpected zero gp_index, topology may be invalid\n", state->global->msgprefix);
     if (obj->gp_index >= topology->next_gp_index)
       topology->next_gp_index = obj->gp_index + 1;
   } else if (!strcmp(name, "id")) { /* forward compat */
     if (!strncmp(value, "obj", 3)) {
       obj->gp_index = strtoull(value+3, NULL, 10);
-      if (!obj->gp_index && hwloc__xml_verbose())
-        fprintf(stderr, "%s: unexpected zero id, topology may be invalid\n", state->global->msgprefix);
+      // if (!obj->gp_index && hwloc__xml_verbose())
+      //  fprintf(stderr, "%s: unexpected zero id, topology may be invalid\n", state->global->msgprefix);
       if (obj->gp_index >= topology->next_gp_index)
         topology->next_gp_index = obj->gp_index + 1;
-    } else {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: unexpected id `%s' not-starting with `obj', ignoring\n", state->global->msgprefix, value);
+    // } else {
+      // if (hwloc__xml_verbose())
+      // fprintf(stderr, "%s: unexpected id `%s' not-starting with `obj', ignoring\n", state->global->msgprefix, value);
     }
   } else if (!strcmp(name, "cpuset")) {
     if (!obj->cpuset)
@@ -172,27 +172,27 @@
     unsigned long long lvalue = strtoull(value, NULL, 10);
     if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
       obj->attr->cache.size = lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring cache_size attribute for non-cache object type\n",
-	      state->global->msgprefix);
+    // else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring cache_size attribute for non-cache object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "cache_linesize")) {
     unsigned long lvalue = strtoul(value, NULL, 10);
     if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
       obj->attr->cache.linesize = lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring cache_linesize attribute for non-cache object type\n",
-	      state->global->msgprefix);
+    //else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring cache_linesize attribute for non-cache object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "cache_associativity")) {
     int lvalue = atoi(value);
     if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
       obj->attr->cache.associativity = lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring cache_associativity attribute for non-cache object type\n",
-	      state->global->msgprefix);
+    // else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring cache_associativity attribute for non-cache object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "cache_type")) {
@@ -202,13 +202,13 @@
 	  || lvalue == HWLOC_OBJ_CACHE_DATA
 	  || lvalue == HWLOC_OBJ_CACHE_INSTRUCTION)
 	obj->attr->cache.type = (hwloc_obj_cache_type_t) lvalue;
-      else
-        if (hwloc__xml_verbose())
-          fprintf(stderr, "%s: ignoring invalid cache_type attribute %lu\n",
-                  state->global->msgprefix, lvalue);
-    } else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring cache_type attribute for non-cache object type\n",
-	      state->global->msgprefix);
+      //else
+        // if (hwloc__xml_verbose())
+         // fprintf(stderr, "%s: ignoring invalid cache_type attribute %lu\n",
+         //         state->global->msgprefix, lvalue);
+    } // else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring cache_type attribute for non-cache object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "local_memory")) {
@@ -217,9 +217,9 @@
       obj->attr->numanode.local_memory = lvalue;
     else if (!obj->parent)
       topology->machine_memory.local_memory = lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring local_memory attribute for non-NUMAnode non-root object\n",
-	      state->global->msgprefix);
+    // else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring local_memory attribute for non-NUMAnode non-root object\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "depth")) {
@@ -228,36 +228,36 @@
 	obj->attr->cache.depth = lvalue;
      } else if (obj->type == HWLOC_OBJ_GROUP || obj->type == HWLOC_OBJ_BRIDGE) {
        /* will be overwritten by the core */
-     } else if (hwloc__xml_verbose())
-       fprintf(stderr, "%s: ignoring depth attribute for object type without depth\n",
-	       state->global->msgprefix);
+      } // else if (hwloc__xml_verbose())
+     //  fprintf(stderr, "%s: ignoring depth attribute for object type without depth\n",
+	 //      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "kind")) {
     unsigned long lvalue = strtoul(value, NULL, 10);
     if (obj->type == HWLOC_OBJ_GROUP)
       obj->attr->group.kind = lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring kind attribute for non-group object type\n",
-	      state->global->msgprefix);
+    // else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring kind attribute for non-group object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "subkind")) {
     unsigned long lvalue = strtoul(value, NULL, 10);
     if (obj->type == HWLOC_OBJ_GROUP)
       obj->attr->group.subkind = lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring subkind attribute for non-group object type\n",
-	      state->global->msgprefix);
+    //else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring subkind attribute for non-group object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "dont_merge")) {
     unsigned long lvalue = strtoul(value, NULL, 10);
     if (obj->type == HWLOC_OBJ_GROUP)
       obj->attr->group.dont_merge = (unsigned char) lvalue;
-    else if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring dont_merge attribute for non-group object type\n",
-	      state->global->msgprefix);
+    // else if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring dont_merge attribute for non-group object type\n",
+	//      state->global->msgprefix);
   }
 
   else if (!strcmp(name, "pci_busid")) {
@@ -267,15 +267,15 @@
       unsigned domain, bus, dev, func;
       if (sscanf(value, "%x:%02x:%02x.%01x",
 		 &domain, &bus, &dev, &func) != 4) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring invalid pci_busid format string %s\n",
-		  state->global->msgprefix, value);
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: ignoring invalid pci_busid format string %s\n",
+	//	  state->global->msgprefix, value);
 	*ignore = 1;
 #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
       } else if (domain > 0xffff) {
 	static int warned = 0;
-	if (!warned && HWLOC_SHOW_ALL_ERRORS())
-	  fprintf(stderr, "hwloc/xml: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
+	// if (!warned && HWLOC_SHOW_ALL_ERRORS())
+	//  fprintf(stderr, "hwloc/xml: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
 	warned = 1;
 	*ignore = 1;
 #endif
@@ -288,9 +288,9 @@
       break;
     }
     default:
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring pci_busid attribute for non-PCI object\n",
-		state->global->msgprefix);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: ignoring pci_busid attribute for non-PCI object\n",
+	//	state->global->msgprefix);
       break;
     }
   }
@@ -302,9 +302,9 @@
       unsigned classid, vendor, device, subvendor, subdevice, revision;
       if (sscanf(value, "%x [%04x:%04x] [%04x:%04x] %02x",
 		 &classid, &vendor, &device, &subvendor, &subdevice, &revision) != 6) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring invalid pci_type format string %s\n",
-		  state->global->msgprefix, value);
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: ignoring invalid pci_type format string %s\n",
+	//	  state->global->msgprefix, value);
       } else {
 	obj->attr->pcidev.class_id = classid;
 	obj->attr->pcidev.vendor_id = vendor;
@@ -316,9 +316,9 @@
       break;
     }
     default:
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring pci_type attribute for non-PCI object\n",
-		state->global->msgprefix);
+      // if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: ignoring pci_type attribute for non-PCI object\n",
+	//	state->global->msgprefix);
       break;
     }
   }
@@ -332,8 +332,8 @@
     }
     default:
       if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring pci_link_speed attribute for non-PCI object\n",
-		state->global->msgprefix);
+	// fprintf(stderr, "%s: ignoring pci_link_speed attribute for non-PCI object\n",
+	//	state->global->msgprefix);
       break;
     }
   }
@@ -343,9 +343,9 @@
     case HWLOC_OBJ_BRIDGE: {
       unsigned upstream_type, downstream_type;
       if (sscanf(value, "%u-%u", &upstream_type, &downstream_type) != 2) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring invalid bridge_type format string %s\n",
-		  state->global->msgprefix, value);
+	//if (hwloc__xml_verbose())
+	  // fprintf(stderr, "%s: ignoring invalid bridge_type format string %s\n",
+		//  state->global->msgprefix, value);
       } else {
 	obj->attr->bridge.upstream_type = (hwloc_obj_bridge_type_t) upstream_type;
 	obj->attr->bridge.downstream_type = (hwloc_obj_bridge_type_t) downstream_type;
@@ -354,9 +354,9 @@
       break;
     }
     default:
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring bridge_type attribute for non-bridge object\n",
-		state->global->msgprefix);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: ignoring bridge_type attribute for non-bridge object\n",
+	//	state->global->msgprefix);
       break;
     }
   }
@@ -367,15 +367,15 @@
       unsigned domain, secbus, subbus;
       if (sscanf(value, "%x:[%02x-%02x]",
 		 &domain, &secbus, &subbus) != 3) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring invalid bridge_pci format string %s\n",
-		  state->global->msgprefix, value);
+	//if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: ignoring invalid bridge_pci format string %s\n",
+	//	  state->global->msgprefix, value);
 	*ignore = 1;
 #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
       } else if (domain > 0xffff) {
 	static int warned = 0;
-	if (!warned && HWLOC_SHOW_ALL_ERRORS())
-	  fprintf(stderr, "hwloc/xml: Ignoring bridge to PCI with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
+	// if (!warned && HWLOC_SHOW_ALL_ERRORS())
+	//  fprintf(stderr, "hwloc/xml: Ignoring bridge to PCI with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
 	warned = 1;
 	*ignore = 1;
 #endif
@@ -388,9 +388,9 @@
       break;
     }
     default:
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring bridge_pci attribute for non-bridge object\n",
-		state->global->msgprefix);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: ignoring bridge_pci attribute for non-bridge object\n",
+	//	state->global->msgprefix);
       break;
     }
   }
@@ -400,17 +400,17 @@
     case HWLOC_OBJ_OS_DEVICE: {
       unsigned osdev_type;
       if (sscanf(value, "%u", &osdev_type) != 1) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring invalid osdev_type format string %s\n",
-		  state->global->msgprefix, value);
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: ignoring invalid osdev_type format string %s\n",
+	//	  state->global->msgprefix, value);
       } else
 	obj->attr->osdev.type = (hwloc_obj_osdev_type_t) osdev_type;
       break;
     }
     default:
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring osdev_type attribute for non-osdev object\n",
-		state->global->msgprefix);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: ignoring osdev_type attribute for non-osdev object\n",
+	//	state->global->msgprefix);
       break;
     }
   }
@@ -447,9 +447,9 @@
 	  obj->attr->numanode.local_memory = lvalue << 10;
 	else if (!obj->parent)
 	  topology->machine_memory.local_memory = lvalue << 10;
-	else if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring memory_kB attribute for non-NUMAnode non-root object\n",
-		  state->global->msgprefix);
+	// else if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: ignoring memory_kB attribute for non-NUMAnode non-root object\n",
+	//	  state->global->msgprefix);
       }
       else if (!strcmp(name, "huge_page_size_kB")) {
 	unsigned long lvalue = strtoul(value, NULL, 10);
@@ -459,11 +459,11 @@
 	    memory->page_types = malloc(sizeof(*memory->page_types));
 	    memory->page_types_len = 1;
 	  }
-	  assert(memory->page_types);
+         //assert(memory->page_types);
 	  memory->page_types[0].size = lvalue << 10;
-	} else if (hwloc__xml_verbose()) {
-	  fprintf(stderr, "%s: ignoring huge_page_size_kB attribute for non-NUMAnode non-root object\n",
-		  state->global->msgprefix);
+	// } else if (hwloc__xml_verbose()) {
+	//  fprintf(stderr, "%s: ignoring huge_page_size_kB attribute for non-NUMAnode non-root object\n",
+	//	  state->global->msgprefix);
 	}
       }
       else if (!strcmp(name, "huge_page_free")) {
@@ -474,11 +474,11 @@
 	    memory->page_types = malloc(sizeof(*memory->page_types));
 	    memory->page_types_len = 1;
 	  }
-	  assert(memory->page_types);
+         //assert(memory->page_types);
 	  memory->page_types[0].count = lvalue;
-	} else if (hwloc__xml_verbose()) {
-	  fprintf(stderr, "%s: ignoring huge_page_free attribute for non-NUMAnode non-root object\n",
-		  state->global->msgprefix);
+	// } else if (hwloc__xml_verbose()) {
+	//  fprintf(stderr, "%s: ignoring huge_page_free attribute for non-NUMAnode non-root object\n",
+	//	  state->global->msgprefix);
 	}
       }
       /* end of deprecated from 0.9 */
@@ -489,9 +489,9 @@
   }
   else {
   unknown:
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring unknown object attribute %s\n",
-	      state->global->msgprefix, name);
+     ;
+      // fprintf(stderr, "%s: ignoring unknown object attribute %s\n",
+	   //   state->global->msgprefix, name);
   }
 }
 
@@ -617,9 +617,9 @@
     matrix = malloc(nbobjs*nbobjs*sizeof(float));
     v1dist = malloc(sizeof(*v1dist));
     if (!matrix || !v1dist) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: failed to allocate v1distance matrix for %lu objects\n",
-		state->global->msgprefix, nbobjs);
+    //   if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: failed to allocate v1distance matrix for %lu objects\n",
+	//	state->global->msgprefix, nbobjs);
       free(v1dist);
       free(matrix);
       return -1;
@@ -670,10 +670,10 @@
 
     if (nbobjs < 2) {
       /* distances with a single object are useless, even if the XML isn't invalid */
-      assert(nbobjs == 1);
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring invalid distance matrix with only 1 object\n",
-		state->global->msgprefix);
+      //assert(nbobjs == 1);
+     // if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: ignoring invalid distance matrix with only 1 object\n",
+	//	state->global->msgprefix);
       free(matrix);
       free(v1dist);
 
@@ -741,7 +741,7 @@
       fakename = malloc(6 + 1 + (name ? strlen(name) : 4) + 1);
       if (!fakename)
 	return -1;
-      sprintf(fakename, encoded ? "base64%c%s" : "normal%c%s", name ? ':' : '-', name ? name : "anon");
+      snprintf(fakename, sizeof(fakename), encoded ? "base64%c%s" : "normal%c%s", name ? ':' : '-', name ? name : "anon");
       topology->userdata_import_cb(topology, obj, fakename, buffer, length);
       free(fakename);
 
@@ -755,7 +755,7 @@
 	char *decoded_buffer = malloc(length+1);
 	if (!decoded_buffer)
 	  return -1;
-	assert(encoded_buffer[encoded_length] == 0);
+       //assert(encoded_buffer[encoded_length] == 0);
 	ret = hwloc_decode_from_base64(encoded_buffer, decoded_buffer, length+1);
 	if (ret != (int) length) {
 	  free(decoded_buffer);
@@ -797,7 +797,7 @@
     hwloc_bitmap_asprintf(&cc2, old->complete_cpuset);
   hwloc_obj_type_snprintf(t2, sizeof(t2), old, 0);
 
-  fprintf(stderr, "****************************************************************************\n");
+  /*fprintf(stderr, "****************************************************************************\n");
   fprintf(stderr, "* hwloc has encountered an out-of-order XML topology load.\n");
   fprintf(stderr, "* Object %s cpuset %s complete %s\n",
 	  t1, c1, cc1);
@@ -814,7 +814,7 @@
     fprintf(stderr, "* the input XML was generated by an unspecified ancient hwloc release.\n");
   fprintf(stderr, "* Please check that your input topology XML file is valid.\n");
   fprintf(stderr, "* Set HWLOC_DEBUG_CHECK=1 in the environment to detect further issues.\n");
-  fprintf(stderr, "****************************************************************************\n");
+  fprintf(stderr, "****************************************************************************\n");*/
 
   free(c1);
   free(cc1);
@@ -853,9 +853,9 @@
 	  if (!parent)
 	    obj->type = HWLOC_OBJ_MACHINE;
 	  else {
-	    if (hwloc__xml_verbose())
-	      fprintf(stderr, "%s: obsolete System object only allowed at root\n",
-		      state->global->msgprefix);
+	    // if (hwloc__xml_verbose())
+	    //  fprintf(stderr, "%s: obsolete System object only allowed at root\n",
+		//      state->global->msgprefix);
 	    goto error_with_object;
 	  }
 	} else if (!strcasecmp(attrvalue, "Tile")) {
@@ -870,22 +870,22 @@
 	  /* ignore possible future type */
 	  obj->type = _HWLOC_OBJ_FUTURE;
 	  ignored = 1;
-	  if (hwloc__xml_verbose())
-	    fprintf(stderr, "%s: %s object not-supported, will be ignored\n",
-		    state->global->msgprefix, attrvalue);
+	  // if (hwloc__xml_verbose())
+	   // fprintf(stderr, "%s: %s object not-supported, will be ignored\n",
+		//    state->global->msgprefix, attrvalue);
 	} else {
-	  if (hwloc__xml_verbose())
-	    fprintf(stderr, "%s: unrecognized object type string %s\n",
-		    state->global->msgprefix, attrvalue);
+	  //if (hwloc__xml_verbose())
+	  //  fprintf(stderr, "%s: unrecognized object type string %s\n",
+		//    state->global->msgprefix, attrvalue);
 	  goto error_with_object;
 	}
       }
     } else {
       /* type needed first */
       if (obj->type == HWLOC_OBJ_TYPE_NONE) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: object attribute %s found before type\n",
-		  state->global->msgprefix,  attrname);
+	//if (hwloc__xml_verbose())
+	  // fprintf(stderr, "%s: object attribute %s found before type\n",
+	//	  state->global->msgprefix,  attrname);
 	goto error_with_object;
       }
       hwloc__xml_import_object_attr(topology, data, obj, attrname, attrvalue, state, &ignored);
@@ -913,9 +913,9 @@
       } else if (!parent) {
 	ret = hwloc__xml_import_pagetype(topology, &topology->machine_memory, &childstate);
       } else {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: invalid non-NUMAnode object child %s\n",
-		  state->global->msgprefix, tag);
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: invalid non-NUMAnode object child %s\n",
+	//	  state->global->msgprefix, tag);
 	ret = -1;
       }
 
@@ -926,9 +926,9 @@
     } else if (!strcmp(tag, "userdata")) {
       ret = hwloc__xml_import_userdata(topology, obj, &childstate);
     } else {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: invalid special object child %s\n",
-		state->global->msgprefix, tag);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: invalid special object child %s\n",
+	//	state->global->msgprefix, tag);
       ret = -1;
     }
 
@@ -947,23 +947,23 @@
     /* check parent/child types for 2.x */
     if (hwloc__obj_type_is_normal(obj->type)) {
       if (!hwloc__obj_type_is_normal(parent->type)) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "normal object %s cannot be child of non-normal parent %s\n",
-		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "normal object %s cannot be child of non-normal parent %s\n",
+	//	  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
 	goto error_with_object;
       }
     } else if (hwloc__obj_type_is_memory(obj->type)) {
       if (hwloc__obj_type_is_io(parent->type) || HWLOC_OBJ_MISC == parent->type) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "Memory object %s cannot be child of non-normal-or-memory parent %s\n",
-		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "Memory object %s cannot be child of non-normal-or-memory parent %s\n",
+	//	  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
 	goto error_with_object;
       }
     } else if (hwloc__obj_type_is_io(obj->type)) {
       if (hwloc__obj_type_is_memory(parent->type) || HWLOC_OBJ_MISC == parent->type) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "I/O object %s cannot be child of non-normal-or-I/O parent %s\n",
-		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
+	//if (hwloc__xml_verbose())
+	//  fprintf(stderr, "I/O object %s cannot be child of non-normal-or-I/O parent %s\n",
+	//	  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
 	goto error_with_object;
       }
     }
@@ -972,16 +972,16 @@
     /* check parent/child types for pre-v2.0 */
     if (hwloc__obj_type_is_normal(obj->type) || HWLOC_OBJ_NUMANODE == obj->type) {
       if (hwloc__obj_type_is_special(parent->type)) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "v1.x normal v1.x object %s cannot be child of special parent %s\n",
-		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
+	//if (hwloc__xml_verbose())
+	//  fprintf(stderr, "v1.x normal v1.x object %s cannot be child of special parent %s\n",
+	//	  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
 	goto error_with_object;
       }
     } else if (hwloc__obj_type_is_io(obj->type)) {
       if (HWLOC_OBJ_MISC == parent->type) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "I/O object %s cannot be child of Misc parent\n",
-		  hwloc_obj_type_string(obj->type));
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "I/O object %s cannot be child of Misc parent\n",
+	//	  hwloc_obj_type_string(obj->type));
 	goto error_with_object;
       }
     }
@@ -995,7 +995,7 @@
     /* attach pre-v2.0 children of NUMA nodes to normal parent */
     if (parent && parent->type == HWLOC_OBJ_NUMANODE) {
       parent = parent->parent;
-      assert(parent);
+      //assert(parent);
     }
 
     /* insert a group above pre-v2.0 NUMA nodes if needed */
@@ -1051,7 +1051,7 @@
 
     /* fixup attribute-less caches imported from pre-v2.0 XMLs */
     if (attribute_less_cache) {
-      assert(obj->type == _HWLOC_OBJ_CACHE_OLD);
+      //(obj->type == _HWLOC_OBJ_CACHE_OLD);
       obj->type = hwloc_cache_type_by_depth_type(obj->attr->cache.depth, obj->attr->cache.type);
     }
 
@@ -1069,9 +1069,9 @@
       if (obj->type == HWLOC_OBJ_GROUP) {
 	ignored = 1;
       } else {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: invalid object %s P#%u with some missing cpusets\n",
-		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
+	// if (hwloc__xml_verbose())
+	  // fprintf(stderr, "%s: invalid object %s P#%u with some missing cpusets\n",
+		//  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
 	goto error_with_object;
       }
     } else if (!obj->nodeset != !obj->complete_nodeset) {
@@ -1079,9 +1079,9 @@
       if (obj->type == HWLOC_OBJ_GROUP) {
 	ignored = 1;
       } else {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: invalid object %s P#%u with some missing nodesets\n",
-		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
+	// if (hwloc__xml_verbose())
+	  // fprintf(stderr, "%s: invalid object %s P#%u with some missing nodesets\n",
+	//	  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
 	goto error_with_object;
       }
     } else if (obj->nodeset && !obj->cpuset) {
@@ -1089,9 +1089,9 @@
       if (obj->type == HWLOC_OBJ_GROUP) {
 	ignored = 1;
       } else {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: invalid object %s P#%u with either cpuset or nodeset missing\n",
-		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: invalid object %s P#%u with either cpuset or nodeset missing\n",
+	//	  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
 	goto error_with_object;
       }
     }
@@ -1108,46 +1108,46 @@
   /* check that cache attributes are coherent with the actual type */
   if (hwloc__obj_type_is_cache(obj->type)
       && obj->type != hwloc_cache_type_by_depth_type(obj->attr->cache.depth, obj->attr->cache.type)) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: invalid cache type %s with attribute depth %u and type %d\n",
-	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->attr->cache.depth, (int) obj->attr->cache.type);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: invalid cache type %s with attribute depth %u and type %d\n",
+	//      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->attr->cache.depth, (int) obj->attr->cache.type);
     goto error_with_object;
   }
 
   /* check special types vs cpuset */
   if (!obj->cpuset && !hwloc__obj_type_is_special(obj->type)) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: invalid normal object %s P#%u without cpuset\n",
-	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: invalid normal object %s P#%u without cpuset\n",
+	//      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
     goto error_with_object;
   }
   if (obj->cpuset && hwloc__obj_type_is_special(obj->type)) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: invalid special object %s with cpuset\n",
-	      state->global->msgprefix, hwloc_obj_type_string(obj->type));
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: invalid special object %s with cpuset\n",
+	//      state->global->msgprefix, hwloc_obj_type_string(obj->type));
     goto error_with_object;
   }
 
   /* check parent vs child sets */
   if (obj->cpuset && parent && !parent->cpuset) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: invalid object %s P#%u with cpuset while parent has none\n",
-	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: invalid object %s P#%u with cpuset while parent has none\n",
+	//      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
     goto error_with_object;
   }
   if (obj->nodeset && parent && !parent->nodeset) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: invalid object %s P#%u with nodeset while parent has none\n",
-	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: invalid object %s P#%u with nodeset while parent has none\n",
+	//      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
     goto error_with_object;
   }
 
   /* check NUMA nodes */
   if (obj->type == HWLOC_OBJ_NUMANODE) {
     if (!obj->nodeset) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: invalid NUMA node object P#%u without nodeset\n",
-		state->global->msgprefix, obj->os_index);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: invalid NUMA node object P#%u without nodeset\n",
+	//	state->global->msgprefix, obj->os_index);
       goto error_with_object;
     }
     data->nbnumanodes++;
@@ -1187,9 +1187,9 @@
 				     &childrengotignored,
 				     &childstate);
     } else {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: invalid special object child %s while looking for objects\n",
-		state->global->msgprefix, tag);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: invalid special object child %s while looking for objects\n",
+	//	state->global->msgprefix, tag);
       ret = -1;
     }
 
@@ -1285,9 +1285,9 @@
     else if (!strcmp(attrname, "value"))
       value = atoi(attrvalue);
     else {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring unknown support attribute %s\n",
-		state->global->msgprefix, attrname);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: ignoring unknown support attribute %s\n",
+	//	state->global->msgprefix, attrname);
     }
   }
 
@@ -1373,9 +1373,9 @@
       nbobjs = strtoul(attrvalue, NULL, 10);
     else if (!strcmp(attrname, "type")) {
       if (hwloc_type_sscanf(attrvalue, &unique_type, NULL, 0) < 0) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: unrecognized %s type %s\n",
-		  state->global->msgprefix, _TAG_NAME, attrvalue);
+	// if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: unrecognized %s type %s\n",
+	//	  state->global->msgprefix, _TAG_NAME, attrvalue);
 	goto out;
       }
     }
@@ -1393,17 +1393,17 @@
       name = attrvalue;
     }
     else {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring unknown %s attribute %s\n",
-		state->global->msgprefix, _TAG_NAME, attrname);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: ignoring unknown %s attribute %s\n",
+	//	state->global->msgprefix, _TAG_NAME, attrname);
     }
   }
 
   /* abort if missing attribute */
   if (!nbobjs || (!heterotypes && unique_type == HWLOC_OBJ_TYPE_NONE) || !indexing || !kind) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: %s missing some attributes\n",
-	      state->global->msgprefix, _TAG_NAME);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: %s missing some attributes\n",
+	//      state->global->msgprefix, _TAG_NAME);
     goto out;
   }
 
@@ -1412,9 +1412,9 @@
   if (heterotypes)
     different_types = malloc(nbobjs*sizeof(*different_types));
   if (!indexes || !u64values || (heterotypes && !different_types)) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: failed to allocate %s arrays for %u objects\n",
-	      state->global->msgprefix, _TAG_NAME, nbobjs);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: failed to allocate %s arrays for %u objects\n",
+	//      state->global->msgprefix, _TAG_NAME, nbobjs);
     goto out_with_arrays;
   }
 
@@ -1438,26 +1438,26 @@
     else if (!strcmp(tag, "u64values"))
       is_u64values = 1;
     if (!is_index && !is_u64values) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: %s with unrecognized child %s\n",
-		state->global->msgprefix, _TAG_NAME, tag);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: %s with unrecognized child %s\n",
+	//	state->global->msgprefix, _TAG_NAME, tag);
       goto out_with_arrays;
     }
 
     if (state->global->next_attr(&childstate, &attrname, &attrvalue) < 0
 	|| strcmp(attrname, "length")) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: %s child must have length attribute\n",
-		state->global->msgprefix, _TAG_NAME);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: %s child must have length attribute\n",
+	//	state->global->msgprefix, _TAG_NAME);
       goto out_with_arrays;
     }
     length = atoi(attrvalue);
 
     ret = state->global->get_content(&childstate, &buffer, length);
     if (ret < 0) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: %s child needs content of length %d\n",
-		state->global->msgprefix, _TAG_NAME, length);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: %s child needs content of length %d\n",
+	//	state->global->msgprefix, _TAG_NAME, length);
       goto out_with_arrays;
     }
 
@@ -1465,9 +1465,9 @@
       /* get indexes */
       const char *tmp, *tmp2;
       if (nr_indexes >= nbobjs) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: %s with more than %u indexes\n",
-		  state->global->msgprefix, _TAG_NAME, nbobjs);
+	// if (hwloc__xml_verbose())
+	  // fprintf(stderr, "%s: %s with more than %u indexes\n",
+	//	  state->global->msgprefix, _TAG_NAME, nbobjs);
 	goto out_with_arrays;
       }
       tmp = buffer;
@@ -1480,16 +1480,16 @@
             /* reached the end of this indexes attribute */
             break;
 	  if (hwloc_type_sscanf(tmp, &t, NULL, 0) < 0) {
-	    if (hwloc__xml_verbose())
-	      fprintf(stderr, "%s: %s with unrecognized heterogeneous type %s\n",
-		      state->global->msgprefix, _TAG_NAME, tmp);
+	    // if (hwloc__xml_verbose())
+	  //    fprintf(stderr, "%s: %s with unrecognized heterogeneous type %s\n",
+		//      state->global->msgprefix, _TAG_NAME, tmp);
 	    goto out_with_arrays;
 	  }
 	  tmp2 = strchr(tmp, ':');
 	  if (!tmp2) {
-	    if (hwloc__xml_verbose())
-	      fprintf(stderr, "%s: %s with missing colon after heterogeneous type %s\n",
-		      state->global->msgprefix, _TAG_NAME, tmp);
+	    // if (hwloc__xml_verbose())
+	    //  fprintf(stderr, "%s: %s with missing colon after heterogeneous type %s\n",
+		//      state->global->msgprefix, _TAG_NAME, tmp);
 	    goto out_with_arrays;
 	  }
 	  tmp = tmp2+1;
@@ -1510,9 +1510,9 @@
       /* get uint64_t values */
       const char *tmp;
       if (nr_u64values >= nbobjs*nbobjs) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: %s with more than %u u64values\n",
-		  state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
+	//if (hwloc__xml_verbose())
+	  // fprintf(stderr, "%s: %s with more than %u u64values\n",
+	//	  state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
 	goto out_with_arrays;
       }
       tmp = buffer;
@@ -1534,9 +1534,9 @@
 
     ret = state->global->close_tag(&childstate);
     if (ret < 0) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: %s with more than %u indexes\n",
-		state->global->msgprefix, _TAG_NAME, nbobjs);
+    //  if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: %s with more than %u indexes\n",
+	//	state->global->msgprefix, _TAG_NAME, nbobjs);
       goto out_with_arrays;
     }
 
@@ -1544,37 +1544,37 @@
   }
 
   if (nr_indexes != nbobjs) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: %s with less than %u indexes\n",
-	      state->global->msgprefix, _TAG_NAME, nbobjs);
+  //  if (hwloc__xml_verbose())
+  //    fprintf(stderr, "%s: %s with less than %u indexes\n",
+	//      state->global->msgprefix, _TAG_NAME, nbobjs);
     goto out_with_arrays;
   }
   if (nr_u64values != nbobjs*nbobjs) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: %s with less than %u u64values\n",
-	      state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
+    // if (hwloc__xml_verbose())
+      // fprintf(stderr, "%s: %s with less than %u u64values\n",
+	 //     state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
     goto out_with_arrays;
   }
 
   if (nbobjs < 2) {
     /* distances with a single object are useless, even if the XML isn't invalid */
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring %s with only %u objects\n",
-	      state->global->msgprefix, _TAG_NAME, nbobjs);
+    // if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: ignoring %s with only %u objects\n",
+	//      state->global->msgprefix, _TAG_NAME, nbobjs);
     goto out_ignore;
   }
   if (unique_type == HWLOC_OBJ_PU || unique_type == HWLOC_OBJ_NUMANODE) {
     if (!os_indexing) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring PU or NUMA %s without os_indexing\n",
-		state->global->msgprefix, _TAG_NAME);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: ignoring PU or NUMA %s without os_indexing\n",
+	//	state->global->msgprefix, _TAG_NAME);
       goto out_ignore;
     }
   } else {
     if (!gp_indexing) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring !PU or !NUMA %s without gp_indexing\n",
-		state->global->msgprefix, _TAG_NAME);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: ignoring !PU or !NUMA %s without gp_indexing\n",
+	//	state->global->msgprefix, _TAG_NAME);
       goto out_ignore;
     }
   }
@@ -1637,30 +1637,30 @@
     else if (!strcmp(attrname, "initiator_obj_type"))
       initiator_obj_type_s = attrvalue;
     else {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: ignoring unknown memattr_value attribute %s\n",
-                state->global->msgprefix, attrname);
+      //if (hwloc__xml_verbose())
+      //  fprintf(stderr, "%s: ignoring unknown memattr_value attribute %s\n",
+      //          state->global->msgprefix, attrname);
       return -1;
     }
   }
 
   if (!target_obj_type_s) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring memattr_value without target_obj_type.\n",
-              state->global->msgprefix);
+    //if (hwloc__xml_verbose())
+      // fprintf(stderr, "%s: ignoring memattr_value without target_obj_type.\n",
+      //        state->global->msgprefix);
     return -1;
   }
   if (hwloc_type_sscanf(target_obj_type_s, &target_obj_type, NULL, 0) < 0) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: failed to identify memattr_value target object type %s\n",
-              state->global->msgprefix, target_obj_type_s);
+    //if (hwloc__xml_verbose())
+      // fprintf(stderr, "%s: failed to identify memattr_value target object type %s\n",
+      //        state->global->msgprefix, target_obj_type_s);
     return -1;
   }
 
   if (!value_s || !target_obj_gp_index_s) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring memattr_value without value and target_obj_gp_index\n",
-              state->global->msgprefix);
+    // if (hwloc__xml_verbose())
+      // fprintf(stderr, "%s: ignoring memattr_value without value and target_obj_gp_index\n",
+      //        state->global->msgprefix);
     return -1;
   }
   target_obj_gp_index = strtoull(target_obj_gp_index_s, NULL, 10);
@@ -1670,9 +1670,9 @@
     /* add a value with initiator */
     struct hwloc_internal_location_s loc;
     if (!initiator_cpuset_s && (!initiator_obj_gp_index_s || !initiator_obj_type_s)) {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: ignoring memattr_value without initiator attributes\n",
-                state->global->msgprefix);
+      // if (hwloc__xml_verbose())
+      //  fprintf(stderr, "%s: ignoring memattr_value without initiator attributes\n",
+      //          state->global->msgprefix);
       return -1;
     }
 
@@ -1681,9 +1681,9 @@
       loc.type = HWLOC_LOCATION_TYPE_CPUSET;
       loc.location.cpuset = hwloc_bitmap_alloc();
       if (!loc.location.cpuset) {
-        if (hwloc__xml_verbose())
-          fprintf(stderr, "%s: failed to allocated memattr_value initiator cpuset\n",
-                  state->global->msgprefix);
+        // if (hwloc__xml_verbose())
+        //  fprintf(stderr, "%s: failed to allocated memattr_value initiator cpuset\n",
+        //          state->global->msgprefix);
         return -1;
       }
       hwloc_bitmap_sscanf(loc.location.cpuset, initiator_cpuset_s);
@@ -1691,9 +1691,9 @@
       loc.type = HWLOC_LOCATION_TYPE_OBJECT;
       loc.location.object.gp_index = strtoull(initiator_obj_gp_index_s, NULL, 10);
       if (hwloc_type_sscanf(initiator_obj_type_s, &loc.location.object.type, NULL, 0) < 0) {
-        if (hwloc__xml_verbose())
-          fprintf(stderr, "%s: failed to identify memattr_value initiator object type %s\n",
-                  state->global->msgprefix, initiator_obj_type_s);
+        // if (hwloc__xml_verbose())
+        //  fprintf(stderr, "%s: failed to identify memattr_value initiator object type %s\n",
+        //          state->global->msgprefix, initiator_obj_type_s);
         return -1;
       }
     }
@@ -1729,9 +1729,9 @@
     else if (!strcmp(attrname, "flags"))
       flags = strtoul(attrvalue, NULL, 10);
     else {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: ignoring unknown memattr attribute %s\n",
-                state->global->msgprefix, attrname);
+      // if (hwloc__xml_verbose())
+        // fprintf(stderr, "%s: ignoring unknown memattr attribute %s\n",
+        //        state->global->msgprefix, attrname);
       return -1;
     }
   }
@@ -1767,9 +1767,9 @@
     if (!strcmp(tag, "memattr_value")) {
       ret = hwloc__xml_import_memattr_value(topology, id, flags, &childstate);
     } else {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: memattr with unrecognized child %s\n",
-                state->global->msgprefix, tag);
+      // if (hwloc__xml_verbose())
+        // fprintf(stderr, "%s: memattr with unrecognized child %s\n",
+        //        state->global->msgprefix, tag);
       ret = -1;
     }
 
@@ -1806,9 +1806,9 @@
     } else if (!strcmp(attrname, "forced_efficiency")) {
       forced_efficiency = atoi(attrvalue);
     } else {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: ignoring unknown cpukind attribute %s\n",
-                state->global->msgprefix, attrname);
+      //if (hwloc__xml_verbose())
+      //  fprintf(stderr, "%s: ignoring unknown cpukind attribute %s\n",
+      //          state->global->msgprefix, attrname);
       hwloc_bitmap_free(cpuset);
       return -1;
     }
@@ -1829,9 +1829,9 @@
       if (!ret && infoname && infovalue)
         hwloc__add_info(&infos, &nr_infos, infoname, infovalue);
     } else {
-      if (hwloc__xml_verbose())
-        fprintf(stderr, "%s: cpukind with unrecognized child %s\n",
-                state->global->msgprefix, tag);
+      //if (hwloc__xml_verbose())
+        //fprintf(stderr, "%s: cpukind with unrecognized child %s\n",
+        //        state->global->msgprefix, tag);
       ret = -1;
     }
 
@@ -1842,9 +1842,9 @@
   }
 
   if (!cpuset) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: ignoring cpukind without cpuset\n",
-              state->global->msgprefix);
+    //if (hwloc__xml_verbose())
+      //fprintf(stderr, "%s: ignoring cpukind without cpuset\n",
+      //        state->global->msgprefix);
     goto error;
   }
 
@@ -1899,9 +1899,9 @@
     else if (!strcmp(attrname, "obj_attr_newvalue"))
       obj_attr_newvalue_s = attrvalue;
     else {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: ignoring unknown diff attribute %s\n",
-		state->global->msgprefix, attrname);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: ignoring unknown diff attribute %s\n",
+	//	state->global->msgprefix, attrname);
       return -1;
     }
   }
@@ -1917,17 +1917,17 @@
 
       /* obj_attr mandatory generic attributes */
       if (!obj_depth_s || !obj_index_s || !obj_attr_type_s) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: missing mandatory obj attr generic attributes\n",
-		  state->global->msgprefix);
+	//if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: missing mandatory obj attr generic attributes\n",
+	//	  state->global->msgprefix);
 	break;
       }
 
       /* obj_attr mandatory attributes common to all subtypes */
       if (!obj_attr_oldvalue_s || !obj_attr_newvalue_s) {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: missing mandatory obj attr value attributes\n",
-		  state->global->msgprefix);
+	//if (hwloc__xml_verbose())
+	//  fprintf(stderr, "%s: missing mandatory obj attr value attributes\n",
+	//	  state->global->msgprefix);
 	break;
       }
 
@@ -1935,8 +1935,8 @@
       obj_attr_type = atoi(obj_attr_type_s);
       if (obj_attr_type == HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO && !obj_attr_name_s) {
 	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: missing mandatory obj attr info name attribute\n",
-		  state->global->msgprefix);
+	//  fprintf(stderr, "%s: missing mandatory obj attr info name attribute\n",
+	//	  state->global->msgprefix);
 	break;
       }
 
@@ -2057,7 +2057,7 @@
    * Not perfect since we may have multiple of them,
    * and some distances might disappear in case of restrict, etc.
    */
-  sprintf(scalestring, "%f", scale);
+  snprintf(scalestring, 20, "%f", scale);
   hwloc_obj_add_info(hwloc_get_root_obj(topology), "xmlv1DistancesScale", scalestring);
 }
 
@@ -2078,11 +2078,11 @@
   hwloc_localeswitch_declare;
   int ret;
 
-  assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
+  //assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
 
   state.global = data;
 
-  assert(!root->cpuset);
+  //assert(!root->cpuset);
 
   hwloc_localeswitch_init();
 
@@ -2095,9 +2095,9 @@
     goto failed;
 
   if (data->version_major > 2) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: cannot import XML version %u.%u > 2\n",
-	      data->msgprefix, data->version_major, data->version_minor);
+    //if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: cannot import XML version %u.%u > 2\n",
+	//      data->msgprefix, data->version_major, data->version_minor);
     goto err;
   }
 
@@ -2111,7 +2111,7 @@
   if (ret < 0)
     goto failed;
   state.global->close_child(&childstate);
-  assert(!gotignored);
+  //assert(!gotignored);
 
   /* the root may have changed if we had to reinsert a Machine */
   root = topology->levels[0][0];
@@ -2145,9 +2145,9 @@
         if (ret < 0)
           goto failed;
       } else {
-	if (hwloc__xml_verbose())
-	  fprintf(stderr, "%s: ignoring unknown tag `%s' after root object.\n",
-		  data->msgprefix, tag);
+	//if (hwloc__xml_verbose())
+	  //fprintf(stderr, "%s: ignoring unknown tag `%s' after root object.\n",
+	//	  data->msgprefix, tag);
 	goto done;
       }
       state.global->close_child(&childstate);
@@ -2159,9 +2159,9 @@
 
 done:
   if (!root->cpuset) {
-    if (hwloc__xml_verbose())
-      fprintf(stderr, "%s: invalid root object without cpuset\n",
-	      data->msgprefix);
+    //if (hwloc__xml_verbose())
+    //  fprintf(stderr, "%s: invalid root object without cpuset\n",
+	//      data->msgprefix);
     goto err;
   }
 
@@ -2193,8 +2193,8 @@
           && !(topology->flags & HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)) {
 	hwloc_obj_t *objs = malloc(nbobjs*sizeof(hwloc_obj_t));
 	uint64_t *values = malloc(nbobjs*nbobjs*sizeof(*values));
-        assert(data->nbnumanodes > 0); /* v1dist->nbobjs is >0 after import */
-        assert(data->first_numanode);
+        //assert(data->nbnumanodes > 0); /* v1dist->nbobjs is >0 after import */
+        //assert(data->first_numanode);
 	if (objs && values) {
 	  hwloc_obj_t node;
 	  unsigned i;
@@ -2229,15 +2229,15 @@
   if (data->version_major >= 2) {
     /* v2 must have non-empty nodesets since at least one NUMA node is required */
     if (!root->nodeset) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: invalid root object without nodeset\n",
-		data->msgprefix);
+  //    if (hwloc__xml_verbose())
+	// fprintf(stderr, "%s: invalid root object without nodeset\n",
+	//	data->msgprefix);
       goto err;
     }
     if (hwloc_bitmap_iszero(root->nodeset)) {
-      if (hwloc__xml_verbose())
-	fprintf(stderr, "%s: invalid root object with empty nodeset\n",
-		data->msgprefix);
+    //  if (hwloc__xml_verbose())
+	//fprintf(stderr, "%s: invalid root object with empty nodeset\n",
+	//	data->msgprefix);
       goto err;
     }
   } else {
@@ -2269,9 +2269,9 @@
  failed:
   if (data->look_done)
     data->look_done(data, -1);
-  if (hwloc__xml_verbose())
-    fprintf(stderr, "%s: XML component discovery failed.\n",
-	    data->msgprefix);
+  // if (hwloc__xml_verbose())
+  //  fprintf(stderr, "%s: XML component discovery failed.\n",
+	//    data->msgprefix);
  err:
   hwloc_free_object_siblings_and_children(root->first_child);
   root->first_child = NULL;
@@ -2314,7 +2314,7 @@
   fakedata.msgprefix = strdup(local_basename);
 
   hwloc_components_init();
-  assert(hwloc_nolibxml_callbacks);
+  //assert(hwloc_nolibxml_callbacks);
 
   hwloc_localeswitch_init();
 
@@ -2353,7 +2353,7 @@
   fakedata.msgprefix = strdup("xmldiffbuffer");
 
   hwloc_components_init();
-  assert(hwloc_nolibxml_callbacks);
+  //assert(hwloc_nolibxml_callbacks);
 
   hwloc_localeswitch_init();
 
@@ -2430,7 +2430,7 @@
     state->new_prop(state, "type", hwloc_obj_type_string(obj->type));
 
   if (obj->os_index != HWLOC_UNKNOWN_INDEX) {
-    sprintf(tmp, "%u", obj->os_index);
+    snprintf(tmp, 11, "%u", obj->os_index);
     state->new_prop(state, "os_index", tmp);
   }
 
@@ -2510,7 +2510,7 @@
   }
 
   if (!v1export) {
-    sprintf(tmp, "%llu", (unsigned long long) obj->gp_index);
+    snprintf(tmp, sizeof(obj->gp_index), "%llu", (unsigned long long) obj->gp_index);
     state->new_prop(state, "gp_index", tmp);
   }
 
@@ -2532,15 +2532,17 @@
   switch (obj->type) {
   case HWLOC_OBJ_NUMANODE:
     if (obj->attr->numanode.local_memory) {
-      sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.local_memory);
+      snprintf(tmp, 21, "%llu", (unsigned long long) obj->attr->numanode.local_memory);
       state->new_prop(state, "local_memory", tmp);
     }
     for(i=0; i<obj->attr->numanode.page_types_len; i++) {
       struct hwloc__xml_export_state_s childstate;
       state->new_child(state, &childstate, "page_type");
-      sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.page_types[i].size);
+      snprintf(tmp, sizeof(obj->attr->numanode.page_types[i].size),
+               "%llu", (unsigned long long) obj->attr->numanode.page_types[i].size);
       childstate.new_prop(&childstate, "size", tmp);
-      sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.page_types[i].count);
+      snprintf(tmp, sizeof(obj->attr->numanode.page_types[i].count),
+               "%llu", (unsigned long long) obj->attr->numanode.page_types[i].count);
       childstate.new_prop(&childstate, "count", tmp);
       childstate.end_object(&childstate, "page_type");
     }
@@ -2554,39 +2556,39 @@
   case HWLOC_OBJ_L2ICACHE:
   case HWLOC_OBJ_L3ICACHE:
   case HWLOC_OBJ_MEMCACHE:
-    sprintf(tmp, "%llu", (unsigned long long) obj->attr->cache.size);
+    snprintf(tmp, 21, "%llu", (unsigned long long) obj->attr->cache.size);
     state->new_prop(state, "cache_size", tmp);
-    sprintf(tmp, "%u", obj->attr->cache.depth);
+    snprintf(tmp, 3,"%u", obj->attr->cache.depth);
     state->new_prop(state, "depth", tmp);
-    sprintf(tmp, "%u", (unsigned) obj->attr->cache.linesize);
+    snprintf(tmp, 3, "%u", (unsigned) obj->attr->cache.linesize);
     state->new_prop(state, "cache_linesize", tmp);
-    sprintf(tmp, "%d", obj->attr->cache.associativity);
+    snprintf(tmp, 3, "%d", obj->attr->cache.associativity);
     state->new_prop(state, "cache_associativity", tmp);
-    sprintf(tmp, "%d", (int) obj->attr->cache.type);
+    snprintf(tmp, 3, "%d", (int) obj->attr->cache.type);
     state->new_prop(state, "cache_type", tmp);
     break;
   case HWLOC_OBJ_GROUP:
     if (v1export) {
-      sprintf(tmp, "%u", obj->attr->group.depth);
+      snprintf(tmp, 3, "%u", obj->attr->group.depth);
       state->new_prop(state, "depth", tmp);
       if (obj->attr->group.dont_merge)
         state->new_prop(state, "dont_merge", "1");
     } else {
-      sprintf(tmp, "%u", obj->attr->group.kind);
+      snprintf(tmp, 3, "%u", obj->attr->group.kind);
       state->new_prop(state, "kind", tmp);
-      sprintf(tmp, "%u", obj->attr->group.subkind);
+      snprintf(tmp, 3, "%u", obj->attr->group.subkind);
       state->new_prop(state, "subkind", tmp);
       if (obj->attr->group.dont_merge)
         state->new_prop(state, "dont_merge", "1");
     }
     break;
   case HWLOC_OBJ_BRIDGE:
-    sprintf(tmp, "%d-%d", (int) obj->attr->bridge.upstream_type, (int) obj->attr->bridge.downstream_type);
+    snprintf(tmp, 6, "%d-%d", (int) obj->attr->bridge.upstream_type, (int) obj->attr->bridge.downstream_type);
     state->new_prop(state, "bridge_type", tmp);
-    sprintf(tmp, "%u", obj->attr->bridge.depth);
+    snprintf(tmp, 3, "%u", obj->attr->bridge.depth);
     state->new_prop(state, "depth", tmp);
     if (obj->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
-      sprintf(tmp, "%04x:[%02x-%02x]",
+      snprintf(tmp, 17, "%04x:[%02x-%02x]",
 	      (unsigned) obj->attr->bridge.downstream.pci.domain,
 	      (unsigned) obj->attr->bridge.downstream.pci.secondary_bus,
 	      (unsigned) obj->attr->bridge.downstream.pci.subordinate_bus);
@@ -2596,23 +2598,23 @@
       break;
     /* FALLTHRU */
   case HWLOC_OBJ_PCI_DEVICE:
-    sprintf(tmp, "%04x:%02x:%02x.%01x",
+    snprintf(tmp, 20, "%04x:%02x:%02x.%01x",
 	    (unsigned) obj->attr->pcidev.domain,
 	    (unsigned) obj->attr->pcidev.bus,
 	    (unsigned) obj->attr->pcidev.dev,
 	    (unsigned) obj->attr->pcidev.func);
     state->new_prop(state, "pci_busid", tmp);
-    sprintf(tmp, "%04x [%04x:%04x] [%04x:%04x] %02x",
+    snprintf(tmp, 34, "%04x [%04x:%04x] [%04x:%04x] %02x",
 	    (unsigned) obj->attr->pcidev.class_id,
 	    (unsigned) obj->attr->pcidev.vendor_id, (unsigned) obj->attr->pcidev.device_id,
 	    (unsigned) obj->attr->pcidev.subvendor_id, (unsigned) obj->attr->pcidev.subdevice_id,
 	    (unsigned) obj->attr->pcidev.revision);
     state->new_prop(state, "pci_type", tmp);
-    sprintf(tmp, "%f", obj->attr->pcidev.linkspeed);
+    snprintf(tmp, 255, "%f", obj->attr->pcidev.linkspeed);
     state->new_prop(state, "pci_link_speed", tmp);
     break;
   case HWLOC_OBJ_OS_DEVICE:
-    sprintf(tmp, "%d", (int) obj->attr->osdev.type);
+    snprintf(tmp, 3, "%d", (int) obj->attr->osdev.type);
     state->new_prop(state, "osdev_type", tmp);
     break;
   default:
@@ -2672,8 +2674,8 @@
 
       logical_to_v2array = malloc(nbobjs * sizeof(*logical_to_v2array));
       if (!logical_to_v2array) {
-        if (HWLOC_SHOW_ALL_ERRORS())
-          fprintf(stderr, "hwloc/xml/export/v1: failed to allocated logical_to_v2array\n");
+        // if (HWLOC_SHOW_ALL_ERRORS())
+        //  fprintf(stderr, "hwloc/xml/export/v1: failed to allocated logical_to_v2array\n");
 	continue;
       }
 
@@ -2709,11 +2711,11 @@
       }
 
       state->new_child(state, &childstate, "distances");
-      sprintf(tmp, "%u", nbobjs);
+      snprintf(tmp, 3, "%u", nbobjs);
       childstate.new_prop(&childstate, "nbobjs", tmp);
-      sprintf(tmp, "%d", depth);
+      snprintf(tmp, 3, "%d", depth);
       childstate.new_prop(&childstate, "relative_depth", tmp);
-      sprintf(tmp, "%f", 1.f);
+      snprintf(tmp, 11, "%f", 1.f);
       childstate.new_prop(&childstate, "latency_base", tmp);
       for(i=0; i<nbobjs; i++) {
         for(j=0; j<nbobjs; j++) {
@@ -2721,7 +2723,7 @@
 	  unsigned k = logical_to_v2array[i]*nbobjs+logical_to_v2array[j];
 	  struct hwloc__xml_export_state_s greatchildstate;
 	  childstate.new_child(&childstate, &greatchildstate, "latency");
-	  sprintf(tmp, "%f", (float) dist->values[k]);
+         snprintf(tmp, 255, "%f", (float) dist->values[k]);
 	  greatchildstate.new_prop(&greatchildstate, "value", tmp);
 	  greatchildstate.end_object(&greatchildstate, "latency");
 	}
@@ -2787,7 +2789,7 @@
  find_first:
   while (cur->type != HWLOC_OBJ_NUMANODE)
     cur = cur->memory_first_child;
-  assert(cur);
+  //assert(cur);
   return cur;
 }
 
@@ -2805,14 +2807,14 @@
   /* we're sure there's at least one numa node */
 
   nr = hwloc_bitmap_weight(obj->nodeset);
-  assert(nr > 0);
+  //assert(nr > 0);
   /* these are local nodes, but some of them may be attached above instead of here */
 
   nodes = calloc(nr, sizeof(*nodes));
   if (!nodes) {
     /* only return the first node */
     cur = hwloc__xml_v1export_object_next_numanode(obj, NULL);
-    assert(cur);
+    //assert(cur);
     *first_p = cur;
     *nodes_p = NULL;
     return 1;
@@ -2931,9 +2933,9 @@
     for(_j=0; \
 	_i+_j<(nr) && _j<maxperline; \
 	_j++) \
-      _len += sprintf(_tmp+_len, format " ", (type) (values)[_i+_j]); \
+      _len += snprintf(_tmp+_len, 255, format " ", (type) (values)[_i+_j]); \
     _i += _j; \
-    sprintf(_tmp2, "%lu", (unsigned long) _len); \
+    snprintf(_tmp2, 16, "%lu", (unsigned long) _len); \
     _childstate.new_prop(&_childstate, "length", _tmp2); \
     _childstate.add_content(&_childstate, _tmp, _len); \
     _childstate.end_object(&_childstate, tagname); \
@@ -2952,9 +2954,9 @@
     for(_j=0; \
 	_i+_j<(nr) && _j<maxperline; \
 	_j++) \
-      _len += sprintf(_tmp+_len, "%s:%llu ", hwloc_obj_type_string((objs)[_i+_j]->type), (unsigned long long) (objs)[_i+_j]->gp_index); \
+      _len += snprintf(_tmp+_len, 255, "%s:%llu ", hwloc_obj_type_string((objs)[_i+_j]->type), (unsigned long long) (objs)[_i+_j]->gp_index); \
     _i += _j; \
-    sprintf(_tmp2, "%lu", (unsigned long) _len); \
+    snprintf(_tmp2, 16, "%lu", (unsigned long) _len); \
     _childstate.new_prop(&_childstate, "length", _tmp2); \
     _childstate.add_content(&_childstate, _tmp, _len); \
     _childstate.end_object(&_childstate, tagname); \
@@ -2975,9 +2977,9 @@
     state.new_prop(&state, "type", hwloc_obj_type_string(dist->unique_type));
   }
 
-  sprintf(tmp, "%u", nbobjs);
+  snprintf(tmp, 10, "%u", nbobjs);
   state.new_prop(&state, "nbobjs", tmp);
-  sprintf(tmp, "%lu", dist->kind);
+  snprintf(tmp, 5, "%lu", dist->kind);
   state.new_prop(&state, "kind", tmp);
   if (dist->name)
     state.new_prop(&state, "name", dist->name);
@@ -3029,7 +3031,7 @@
       parentstate->new_child(parentstate, &state, "support");   \
       state.new_prop(&state, "name", #_cat "." #_name);         \
       if (topology->support._cat->_name != 1) {                 \
-        sprintf(tmp, "%u", topology->support._cat->_name); \
+        snprintf(tmp, 4, "%u", topology->support._cat->_name); \
         state.new_prop(&state, "value", tmp);                   \
       }                                                         \
       state.end_object(&state, "support");                      \
@@ -3115,7 +3117,7 @@
         break;
       }
       default:
-        assert(0);
+        break;
       }
       vstate.end_object(&vstate, "memattr_value");
     }
@@ -3264,26 +3266,29 @@
 
     parentstate->new_child(parentstate, &state, "diff");
 
-    sprintf(tmp, "%d", (int) diff->generic.type);
+    snprintf(tmp, 3, "%d", (int) diff->generic.type);
     state.new_prop(&state, "type", tmp);
 
     switch (diff->generic.type) {
     case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR:
-      sprintf(tmp, "%d", diff->obj_attr.obj_depth);
+      snprintf(tmp, 3, "%d", diff->obj_attr.obj_depth);
       state.new_prop(&state, "obj_depth", tmp);
-      sprintf(tmp, "%u", diff->obj_attr.obj_index);
+      snprintf(tmp, 3, "%u", diff->obj_attr.obj_index);
       state.new_prop(&state, "obj_index", tmp);
 
-      sprintf(tmp, "%d", (int) diff->obj_attr.diff.generic.type);
+      snprintf(tmp, 3, "%d", (int) diff->obj_attr.diff.generic.type);
       state.new_prop(&state, "obj_attr_type", tmp);
 
       switch (diff->obj_attr.diff.generic.type) {
       case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
-	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.index);
+       snprintf(tmp, sizeof(diff->obj_attr.diff.uint64.index), "%llu",
+             (unsigned long long) diff->obj_attr.diff.uint64.index);
 	state.new_prop(&state, "obj_attr_index", tmp);
-	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.oldvalue);
+       snprintf(tmp, sizeof(diff->obj_attr.diff.uint64.oldvalue),
+            "%llu", (unsigned long long) diff->obj_attr.diff.uint64.oldvalue);
 	state.new_prop(&state, "obj_attr_oldvalue", tmp);
-	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.newvalue);
+       snprintf(tmp, sizeof(diff->obj_attr.diff.uint64.newvalue),
+             "%llu", (unsigned long long) diff->obj_attr.diff.uint64.newvalue);
 	state.new_prop(&state, "obj_attr_newvalue", tmp);
 	break;
       case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
@@ -3297,7 +3302,7 @@
 
       break;
     default:
-      assert(0);
+      break;
     }
     state.end_object(&state, "diff");
 
@@ -3322,7 +3327,7 @@
     return -1;
   }
 
-  assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the topology */
+  //assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the topology */
 
   if (flags & ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
     errno = EINVAL;
@@ -3370,7 +3375,7 @@
     return -1;
   }
 
-  assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the topology */
+  //assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the topology */
 
   if (flags & ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
     errno = EINVAL;
@@ -3425,7 +3430,7 @@
   }
 
   hwloc_components_init();
-  assert(hwloc_nolibxml_callbacks);
+  //assert(hwloc_nolibxml_callbacks);
 
   hwloc_localeswitch_init();
 
@@ -3466,7 +3471,7 @@
   }
 
   hwloc_components_init();
-  assert(hwloc_nolibxml_callbacks);
+  //assert(hwloc_nolibxml_callbacks);
 
   hwloc_localeswitch_init();
 
@@ -3491,7 +3496,7 @@
 {
   int force_nolibxml;
 
-  assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the topology */
+  //assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the topology */
 
   force_nolibxml = hwloc_nolibxml_export();
   if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
@@ -3516,7 +3521,7 @@
   parentstate->new_child(parentstate, &state, "userdata");
   if (name)
     state.new_prop(&state, "name", name);
-  sprintf(tmp, "%lu", (unsigned long) length);
+  snprintf(tmp, sizeof(length), "%lu", (unsigned long) length);
   state.new_prop(&state, "length", tmp);
   if (encoded)
     state.new_prop(&state, "encoding", "base64");
@@ -3547,19 +3552,19 @@
     int encoded;
     size_t encoded_length;
     const char *realname;
-    assert(name);
+    //assert(name);
     if (!strncmp(name, "base64", 6)) {
       encoded = 1;
       encoded_length = BASE64_ENCODED_LENGTH(length);
     } else {
-      assert(!strncmp(name, "normal", 6));
+      //assert(!strncmp(name, "normal", 6));
       encoded = 0;
       encoded_length = length;
     }
     if (name[6] == ':')
       realname = name+7;
     else {
-      assert(!strcmp(name+6, "-anon"));
+      //assert(!strcmp(name+6, "-anon"));
       realname = NULL;
     }
     hwloc__export_obj_userdata(state, encoded, realname, length, buffer, encoded_length);
@@ -3585,7 +3590,7 @@
     return -1;
   }
 
-  assert(!topology->userdata_not_decoded);
+  //assert(!topology->userdata_not_decoded);
 
   if (name && hwloc__xml_export_check_buffer(name, strlen(name)) < 0) {
     errno = EINVAL;
@@ -3600,7 +3605,7 @@
   }
 
   ret = hwloc_encode_to_base64(buffer, length, encoded_buffer, encoded_length+1);
-  assert(ret == (int) encoded_length);
+  //assert(ret == (int) encoded_length);
 
   hwloc__export_obj_userdata(state, 1, name, length, encoded_buffer, encoded_length);
 
@@ -3646,7 +3651,7 @@
   const char *local_basename;
   int err;
 
-  assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the component's topology */
+  //assert(hwloc_nolibxml_callbacks); /* the core called components_init() for the component's topology */
 
   if (!xmlpath && !xmlbuffer) {
     env = getenv("HWLOC_XMLFILE");
