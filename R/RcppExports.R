# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Alternating Direction Method of Multipliers NMF
#'
#' Use the AOADMM algorithm to factor a given matrix at the given rank.
#'
#' @param x Input matrix for factorization
#' @param k Factor matrix rank
#' @param niter Maximum number of nmf iterations
#' @param H_init Initial right-hand factor matrix (Optional)
#' @param W_init Initial left-hand factor matrix (Optional)
#' @returns The calculated factor matrices as an Rcpp::List
#' @examplesIf require("Matrix")
#' aoadmmnmf(rsparsematrix(nrow = 100, ncol = 100, nnz = 10, symmetric = TRUE), 10, 10)
aoadmmnmf <- function(x, k, niter, W_init = NULL, H_init = NULL) {
    .Call(`_RcppPlanc_aoadmmnmf`, x, k, niter, W_init, H_init)
}

#' Gauss-Newton using Conjugate Gradients NMF
#'
#' Use the Gauss-Newton algorithm to factor a given matrix at the given rank.
#'
#' @param x Input matrix for factorization
#' @param k Factor matrix rank
#' @param niter Maximum number of nmf iterations
#' @param H_init Initial right-hand factor matrix (Optional)
#' @param W_init Initial left-hand factor matrix (Optional)
#' @returns The calculated factor matrices as an Rcpp::List
#' @examplesIf require("Matrix")
#' gnsymnmf(rsparsematrix(nrow = 100, ncol = 100, nnz = 10, symmetric = TRUE), 10, 10)
gnsymnmf <- function(x, k, niter, W_init = NULL, H_init = NULL) {
    .Call(`_RcppPlanc_gnsymnmf`, x, k, niter, W_init, H_init)
}

#' Hierarchical Alternating Least Squares NMF
#'
#' Use the HALS algorithm to factor a given matrix at the given rank.
#'
#' @param x Input matrix for factorization
#' @param k Factor matrix rank
#' @param niter Maximum number of nmf iterations
#' @param H_init Initial right-hand factor matrix (Optional)
#' @param W_init Initial left-hand factor matrix (Optional)
#' @returns The calculated factor matrices as an Rcpp::List
#' @examplesIf require("Matrix")
#' halsmnmf(rsparsematrix(nrow = 100, ncol = 100, nnz = 10, symmetric = TRUE), 10, 10)
halsnmf <- function(x, k, niter, W_init = NULL, H_init = NULL) {
    .Call(`_RcppPlanc_halsnmf`, x, k, niter, W_init, H_init)
}

#' Multiplicative Update NMF
#'
#' Use the MU algorithm to factor a given matrix
#' at the given rank.
#' @param x Input matrix for factorization
#' @param k Factor matrix rank
#' @param niter Maximum number of nmf iterations
#' @param H_init Initial right-hand factor matrix (Optional)
#' @param W_init Initial left-hand factor matrix (Optional)
#' @returns The calculated factor matrices as an Rcpp::List
#' @examplesIf require("Matrix")
#' halsnmf(rsparsematrix(nrow = 100, ncol = 100, nnz = 10, symmetric = TRUE), 10, 10)
munmf <- function(x, k, niter, W_init = NULL, H_init = NULL) {
    .Call(`_RcppPlanc_munmf`, x, k, niter, W_init, H_init)
}

#' Alternating  Nonnegative Least Squares with Block Principal Pivoting NMF
#'
#' Use the ANLS-BPP algorithm to factor a given matrix at the given rank.
#'
#' @param x Input matrix for factorization
#' @param k Factor matrix rank
#' @param niter Maximum number of nmf iterations
#' @param H_init Initial right-hand factor matrix (Optional)
#' @param W_init Initial left-hand factor matrix (Optional)
#' @returns The calculated factor matrices as an Rcpp::List
#' @examplesIf require("Matrix")
#' munmf(rsparsematrix(nrow = 100, ncol = 100, nnz = 10, symmetric = TRUE), 10, 10)
bppnmf <- function(x, k, niter, W_init = NULL, H_init = NULL) {
    .Call(`_RcppPlanc_bppnmf`, x, k, niter, W_init, H_init)
}

#' Block Principal Pivoted Non-Negative Least Squares
#'
#' Use the BPP algorithm to get the nonnegative least squares solution. Regular
#' NNLS problem is described as optimizing \eqn{\min_{x\ge0}||CX - B||_F^2}
#' where \eqn{C} and \eqn{B} are given and \eqn{X} is to be solved.
#' \code{bppnnls} takes \eqn{C} and \eqn{B} as input. \code{bppnnls_prod} takes
#' \eqn{C^\mathsf{T}C} and \eqn{C^\mathsf{T}B} as
#' input to directly go for the intermediate step of BPP algorithm. This can be
#' useful when the dimensionality of \eqn{C} and \eqn{B} is large while
#' pre-calculating \eqn{C^\mathsf{T}C} and \eqn{C^\mathsf{T}B} is cheap.
#'
#' @param C Input dense \eqn{C} matrix
#' @param B Input \eqn{B} matrix of either dense or sparse form
#' @returns The calculated solution matrix in dense form.
#' @rdname bppnnls
#' @examples
#' set.seed(1)
#' C <- matrix(rnorm(1000), nrow = 100)
#' B <- matrix(rnorm(1500), nrow = 100)
#' res1 <- bppnnls(C, B)
#' dim(res1)
#' res2 <- bppnnls_prod(t(C) %*% C, t(C) %*% B)
#' all.equal(res1, res2)
bppnnls <- function(C, B) {
    .Call(`_RcppPlanc_bppnnls`, C, B)
}

#' @param CtC The \eqn{C^\mathsf{T}C} matrix, see description.
#' @param CtB The \eqn{C^\mathsf{T}B} matrix, see description.
#' @rdname bppnnls
bppnnls_prod <- function(CtC, CtB) {
    .Call(`_RcppPlanc_bppnnls_prod`, CtC, CtB)
}

.bppinmf <- function(objectList, k, lambda = 5, niter = 30L, verbose = TRUE, Hinit = NULL, Vinit = NULL, Winit = NULL) {
    .Call(`_RcppPlanc_bppinmf`, objectList, k, lambda, niter, verbose, Hinit, Vinit, Winit)
}

.bppinmf_h5dense <- function(filenames, dataPath, k, lambda, niter, verbose = TRUE, Hinit = NULL, Vinit = NULL, Winit = NULL) {
    .Call(`_RcppPlanc_bppinmf_h5dense`, filenames, dataPath, k, lambda, niter, verbose, Hinit, Vinit, Winit)
}

.bppinmf_h5sparse <- function(filenames, valuePath, rowindPath, colptrPath, nrow, ncol, k, lambda, niter, verbose = TRUE, Hinit = NULL, Vinit = NULL, Winit = NULL) {
    .Call(`_RcppPlanc_bppinmf_h5sparse`, filenames, valuePath, rowindPath, colptrPath, nrow, ncol, k, lambda, niter, verbose, Hinit, Vinit, Winit)
}

.onlineINMF_S1 <- function(objectList, k, lambda, maxEpoch = 5L, minibatchSize = 5000L, maxHALSIter = 1L, verbose = TRUE) {
    .Call(`_RcppPlanc_onlineINMF_S1`, objectList, k, lambda, maxEpoch, minibatchSize, maxHALSIter, verbose)
}

.onlineINMF_S1_h5dense <- function(filenames, dataPaths, k, lambda, maxEpoch = 5L, minibatchSize = 5000L, maxHALSIter = 1L, verbose = TRUE) {
    .Call(`_RcppPlanc_onlineINMF_S1_h5dense`, filenames, dataPaths, k, lambda, maxEpoch, minibatchSize, maxHALSIter, verbose)
}

.onlineINMF_S1_h5sparse <- function(filenames, valuePaths, rowindPaths, colptrPaths, nrows, ncols, k, lambda, maxEpoch = 5L, minibatchSize = 5000L, maxHALSIter = 1L, verbose = TRUE) {
    .Call(`_RcppPlanc_onlineINMF_S1_h5sparse`, filenames, valuePaths, rowindPaths, colptrPaths, nrows, ncols, k, lambda, maxEpoch, minibatchSize, maxHALSIter, verbose)
}

.onlineINMF_S23 <- function(objectList, Vinit, Winit, Ainit, Binit, objectListNew, k, lambda, project = FALSE, maxEpoch = 5L, minibatchSize = 5000L, maxHALSIter = 1L, verbose = TRUE) {
    .Call(`_RcppPlanc_onlineINMF_S23`, objectList, Vinit, Winit, Ainit, Binit, objectListNew, k, lambda, project, maxEpoch, minibatchSize, maxHALSIter, verbose)
}

.onlineINMF_S23_h5dense <- function(filenames, dataPaths, filenamesNew, dataPathsNew, Vinit, Winit, Ainit, Binit, k, lambda, project = FALSE, maxEpoch = 5L, minibatchSize = 5000L, maxHALSIter = 1L, verbose = TRUE) {
    .Call(`_RcppPlanc_onlineINMF_S23_h5dense`, filenames, dataPaths, filenamesNew, dataPathsNew, Vinit, Winit, Ainit, Binit, k, lambda, project, maxEpoch, minibatchSize, maxHALSIter, verbose)
}

.onlineINMF_S23_h5sparse <- function(filenames, valuePaths, rowindPaths, colptrPaths, nrows, ncols, filenamesNew, valuePathsNew, rowindPathsNew, colptrPathsNew, nrowsNew, ncolsNew, Vinit, Winit, Ainit, Binit, k, lambda, project = FALSE, maxEpoch = 5L, minibatchSize = 5000L, maxHALSIter = 1L, verbose = TRUE) {
    .Call(`_RcppPlanc_onlineINMF_S23_h5sparse`, filenames, valuePaths, rowindPaths, colptrPaths, nrows, ncols, filenamesNew, valuePathsNew, rowindPathsNew, colptrPathsNew, nrowsNew, ncolsNew, Vinit, Winit, Ainit, Binit, k, lambda, project, maxEpoch, minibatchSize, maxHALSIter, verbose)
}

.uinmf_rcpp <- function(objectList, unsharedList, k, lambda, niter, verbose) {
    .Call(`_RcppPlanc_uinmf_rcpp`, objectList, unsharedList, k, lambda, niter, verbose)
}

.uinmf_h5dense <- function(filenames, dataPaths, unsharedFilenames, unsharedDataPaths, k, lambda, niter, verbose) {
    .Call(`_RcppPlanc_uinmf_h5dense`, filenames, dataPaths, unsharedFilenames, unsharedDataPaths, k, lambda, niter, verbose)
}

.uinmf_h5sparse <- function(filenames, rowindPaths, colptrPaths, valuePaths, nrows, ncols, unsharedFilenames, unsharedRowindPaths, unsharedColptrPaths, unsharedValuePaths, unsharedNrows, unsharedNcols, k, lambda, niter, verbose) {
    .Call(`_RcppPlanc_uinmf_h5sparse`, filenames, rowindPaths, colptrPaths, valuePaths, nrows, ncols, unsharedFilenames, unsharedRowindPaths, unsharedColptrPaths, unsharedValuePaths, unsharedNrows, unsharedNcols, k, lambda, niter, verbose)
}

